<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<title>GO语言面试系列:（二）常规性Golang面试题解析  - Go语言中文网 - Golang中文社区</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
	<meta charset="utf-8">
	<link rel="shortcut icon" href="https://static.studygolang.com/img/favicon.ico">
	<link rel="apple-touch-icon" type="image/png" href="https://static.studygolang.com/static/img/logo2.png">
	<meta name="keywords" content="Go,Golang,Go语言">
<meta name="description" content="最近在很多地方看到了golang的面试题，看到了很多人对Golang的面试题心存恐惧，也是为了复习基础，我把解题的过程总结下来。 面试题 1. 写出下面代码输出内容。 package main import ( &#34;fmt&#34; ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(&#34;打印前&#34;) }()">
	<meta name="author" content="polaris <polaris@studygolang.com>">
	<link rel="canonical" href="https://studygolang.com/" />

	
	<link rel="stylesheet" href="https://static.studygolang.com/cssjs/fonts_googleapi.css">
	<link rel="stylesheet" href="https://static.studygolang.com/cssjs/cosmo_bootstrap.min.css">
	<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="https://static.studygolang.com/static/dist/css/sg_libs.min.css"/>
	<link rel="stylesheet" href="https://static.studygolang.com/static/dist/css/sg_styles.min.css?v=0.3"/>
	
	

<style>
pre .line { margin: auto; line-height: 20px; border-bottom: none; }
.image-package .image-container-fill { padding-bottom: 0 !important; }
</style>



<link href="https://cdn.staticfile.org/prism/9000.0.1/themes/prism-okaidia.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/prism/9000.0.1/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">




	
	<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
	<script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
	
</head>
<body>
	<header class="navbar navbar-default navbar-fixed-top" role="navigation" style="position:relative;">
		<div class="container">
			
			<div class="navbar-header">
				<a href="/" class="navbar-brand" title="Go语言中文网"><img alt="Go语言中文网" src="https://static.studygolang.com/img/logo1.png" style="margin-top: -7px; height: 45px;"></a>
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
			</div>
			<div class="navbar-collapse collapse" id="navbar-main">
				<ul class="nav navbar-nav">
					<li class="">
						<a href="/topics">主题</a>
					</li>
					<li class="active">
						<a href="/articles">文章</a>
					</li>
					<li class="">
						<a href="/projects">项目</a>
					</li>
					<li class="">
						<a href="/resources">资源</a>
					</li>
					<li class="">
						<a href="/books">图书</a>
					</li>
					<li class="dropdown ">
						
						<a class="dropdown-toggle" data-toggle="dropdown" href="#" id="readings">晨读 <span class="caret"></span></a>
						<ul class="dropdown-menu" aria-labelledby="readings">
							<li><a href="/readings">Go晨读</a></li>
							<li><a href="/readings?rtype=1">综合晨读</a></li>
						</ul>
						
					</li>
					<li class="">
						<a href="/dl">下载<i class="newfuture"></i></a>
					</li>
					<li class="dropdown ">
						<a class="dropdown-toggle" data-toggle="dropdown" href="#" id="docs">官方文档 <span class="caret"></span></a>
						<ul class="dropdown-menu" aria-labelledby="docs">
						
							<li><a href="http://docs.studygolang.com" target="_blank">英文文档</a></li>
							<li><a href="http://docscn.studygolang.com" target="_blank">中文文档</a></li>
							<li><a href="/pkgdoc">标准库中文版</a></li>
							<li role="presentation" class="divider"></li>
							<li><a href="http://tour.studygolang.com" target="_blank">Go指南</a></li>
						
						</ul>
					</li>
				</ul>
				<form class="navbar-form navbar-left" action="/search" role="search" target="_blank">
					<input type="text" name="q" class="form-control search-query" placeholder="搜索" value="">
				</form>
				<ul class="nav navbar-nav navbar-right" id="userbar">
					
					<li class="first"><a href="/account/register">注册</a></li><li class="last"><a href="/account/login">登录</a></li>
					
				</ul>
			</div>
		</div>
	</header>
	<div class="wrapper" id="wrapper">
		<div class="container" role="main">
		

			
<div class="row">
	<div class="col-md-9 col-sm-6">
		<div class="sep20"></div>
		<ol class="breadcrumb">
			<li><a href="/">首页</a></li>
			<li><a href="/articles">文章</a></li>
		</ol>
		<div class="page">
			<div class="box_white">
				<div class="title">
					
					<h1 id="title" data-id="15777">
						GO语言面试系列:（二）常规性Golang面试题解析
					</h1>
					<small class="c9">
					
						
						<span>Chole121</span>
						
					
						 · <span title="2018-10-25 13:34:38" class="timeago"></span> · 97 次点击 · 
						<span class="read-time"></span> · 
						<span class="timeago" title="2018-10-25 19:54:05"></span> 开始浏览 &nbsp; &nbsp;
					
					</small>
				</div>
				
				<div class="cell">
					
					<div id="myeditor" class="content article-entry">
						<div class="show-content-free">
            <p>最近在很多地方看到了<a href="https://zhuanlan.zhihu.com/p/26972862" target="_blank" rel="nofollow">golang的面试题</a>，看到了很多人对Golang的面试题心存恐惧，也是为了复习基础，我把解题的过程总结下来。</p>
<h1>面试题</h1>
<h2>1. 写出下面代码输出内容。</h2>
<pre><code>package main

import (
    &#34;fmt&#34;
)

func main() {
    defer_call()
}

func defer_call() {
    defer func() { fmt.Println(&#34;打印前&#34;) }()
    defer func() { fmt.Println(&#34;打印中&#34;) }()
    defer func() { fmt.Println(&#34;打印后&#34;) }()

    panic(&#34;触发异常&#34;)
}
</code></pre>
<p><strong>考点：defer执行顺序</strong><br/>
解答：defer 是后进先出。panic 需要等defer 结束后才会向上传递。<br/>
出现panic恐慌时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。</p>
<pre><code>打印后
打印中
打印前
panic: 触发异常
</code></pre>
<p>近期有同学遇到多次执行的时候发现panic的执行顺序不定，那么是不是因为panic与defer没有先后关系呢？我们先来下面的例子：</p>
<pre><code>func main() {
    defer_call()
}

func defer_call() {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println(&#34;one=&#34;, err)
        }
    }()
    defer func() { fmt.Println(&#34;打印前&#34;) }()
    defer func() { fmt.Println(&#34;打印中&#34;) }()
    defer func() { fmt.Println(&#34;打印后&#34;) }()

    panic(&#34;触发异常&#34;)

}
</code></pre>
<p>大家再多次执行，看看是否都是输出：</p>
<pre><code>打印后
打印中
打印前
one= 触发异常
</code></pre>
<p>那为什么没有加recover()时候，panic执行顺序不定呢？<br/>
defer的执行顺序肯定是FILO的，但是没有被recover的panic协程（线程）可能争夺CPU的顺序比defer快，所以造成了这样的情况，也可能是写缓存问题，所以对panic进行recover将其加入到defer队列中。</p>
<h2>2. 以下代码有什么问题，说明原因。</h2>
<pre><code>type student struct {
    Name string
    Age  int
}

func pase_student() {
    m := make(map[string]*student)
    stus := []student{
        {Name: &#34;zhou&#34;, Age: 24},
        {Name: &#34;li&#34;, Age: 23},
        {Name: &#34;wang&#34;, Age: 22},
    }
    for _, stu := range stus {
        m[stu.Name] = &amp;stu
    }

}
</code></pre>
<p><strong>考点：foreach</strong><br/>
解答：这样的写法初学者经常会遇到的，很危险！<br/>
与Java的foreach一样，都是使用副本的方式。所以m[stu.Name]=&amp;stu实际上一致指向同一个指针， 最终该指针的值为遍历的最后一个struct的值拷贝。 就像想修改切片元素的属性：</p>
<pre><code>for _, stu := range stus {
    stu.Age = stu.Age+10
}
</code></pre>
<p>也是不可行的。 大家可以试试打印出来：</p>
<pre><code>func pase_student() {
    m := make(map[string]*student)
    stus := []student{
        {Name: &#34;zhou&#34;, Age: 24},
        {Name: &#34;li&#34;, Age: 23},
        {Name: &#34;wang&#34;, Age: 22},
    }
    // 错误写法
    for _, stu := range stus {
        m[stu.Name] = &amp;stu
    }

    for k,v:=range m{
        println(k,&#34;=&gt;&#34;,v.Name)
    }

    // 正确
    for i:=0;i&lt;len(stus);i++  {
        m[stus[i].Name] = &amp;stus[i]
    }
    for k,v:=range m{
        println(k,&#34;=&gt;&#34;,v.Name)
    }
}
</code></pre>
<h3>3. 下面的代码会输出什么，并说明原因</h3>
<pre><code>func main() {
    runtime.GOMAXPROCS(1)
    wg := sync.WaitGroup{}
    wg.Add(20)
    for i := 0; i &lt; 10; i++ {
        go func() {
            fmt.Println(&#34;A: &#34;, i)
            wg.Done()
        }()
    }
    for i := 0; i &lt; 10; i++ {
        go func(i int) {
            fmt.Println(&#34;B: &#34;, i)
            wg.Done()
        }(i)
    }
    wg.Wait()
}
</code></pre>
<p><strong>考点：go执行的随机性和闭包</strong><br/>
解答：谁也不知道执行后打印的顺序是什么样的，所以只能说是随机数字。<br/>
但是A:均为输出10，B:从0~9输出(顺序不定)。 第一个go func中i是外部for的一个变量，地址不变化。遍历完成后，最终i=10。 故go func执行时，i的值始终是10。</p>
<p>第二个go func中i是函数参数，与外部for中的i完全是两个变量。 尾部(i)将发生值拷贝，go func内部指向值拷贝地址。</p>
<h3>4. 下面代码会输出什么？</h3>
<pre><code>type People struct{}

func (p *People) ShowA() {
    fmt.Println(&#34;showA&#34;)
    p.ShowB()
}
func (p *People) ShowB() {
    fmt.Println(&#34;showB&#34;)
}

type Teacher struct {
    People
}

func (t *Teacher) ShowB() {
    fmt.Println(&#34;teacher showB&#34;)
}

func main() {
    t := Teacher{}
    t.ShowA()
}
</code></pre>
<p><strong>考点：go的组合继承</strong><br/>
解答：这是Golang的组合模式，可以实现OOP的继承。 被组合的类型People所包含的方法虽然升级成了外部类型Teacher这个组合类型的方法（一定要是匿名字段），但它们的方法(ShowA())调用时接受者并没有发生变化。 此时People类型并不知道自己会被什么类型组合，当然也就无法调用方法时去使用未知的组合者Teacher类型的功能。</p>
<pre><code>showA
showB
</code></pre>
<h3>5. 下面代码会触发异常吗？请详细说明</h3>
<pre><code>func main() {
    runtime.GOMAXPROCS(1)
    int_chan := make(chan int, 1)
    string_chan := make(chan string, 1)
    int_chan &lt;- 1
    string_chan &lt;- &#34;hello&#34;
    select {
    case value := &lt;-int_chan:
        fmt.Println(value)
    case value := &lt;-string_chan:
        panic(value)
    }
}
</code></pre>
<p><strong>考点：select随机性</strong><br/>
解答：select会随机选择一个可用通用做收发操作。 所以代码是有肯触发异常，也有可能不会。<br/>
单个chan如果无缓冲时，将会阻塞。但结合 select可以在多个chan间等待执行。有三点原则：</p>
<ul>
<li>select 中只要有一个case能return，则立刻执行。</li>
<li>当如果同一时间有多个case均能return则伪随机方式抽取任意一个执行。</li>
<li>如果没有一个case能return则可以执行”default”块。</li>
</ul>
<h3>6. 下面代码输出什么？</h3>
<pre><code>func calc(index string, a, b int) int {
    ret := a + b
    fmt.Println(index, a, b, ret)
    return ret
}

func main() {
    a := 1
    b := 2
    defer calc(&#34;1&#34;, a, calc(&#34;10&#34;, a, b))
    a = 0
    defer calc(&#34;2&#34;, a, calc(&#34;20&#34;, a, b))
    b = 1
}
</code></pre>
<p><strong>考点：defer执行顺序</strong><br/>
解答：<br/>
这道题类似第1题 需要注意到defer执行顺序和值传递 index:1肯定是最后执行的，但是index:1的第三个参数是一个函数，所以最先被调用calc(“10”,1,2)==&gt;10,1,2,3 执行index:2时,与之前一样，需要先调用calc(“20”,0,2)==&gt;20,0,2,2 执行到b=1时候开始调用，index:2==&gt;calc(“2”,0,2)==&gt;2,0,2,2 最后执行index:1==&gt;calc(“1”,1,3)==&gt;1,1,3,4</p>
<pre><code>10 1 2 3
20 0 2 2
2 0 2 2
1 1 3 4
</code></pre>
<h3>7. 请写出以下输入内容</h3>
<pre><code>func main() {
    s := make([]int, 5)
    s = append(s, 1, 2, 3)
    fmt.Println(s)
}
</code></pre>
<p><strong>考点：make默认值和append</strong><br/>
解答：make初始化是由默认值的哦，此处默认值为0</p>
<pre><code>[0 0 0 0 0 1 2 3]
</code></pre>
<p>大家试试改为:</p>
<pre><code>s := make([]int, 0)
s = append(s, 1, 2, 3)
fmt.Println(s)//[1 2 3]
</code></pre>
<h3>8. 下面的代码有什么问题?</h3>
<pre><code>type UserAges struct {
    ages map[string]int
    sync.Mutex
}

func (ua *UserAges) Add(name string, age int) {
    ua.Lock()
    defer ua.Unlock()
    ua.ages[name] = age
}

func (ua *UserAges) Get(name string) int {
    if age, ok := ua.ages[name]; ok {
        return age
    }
    return -1
}
</code></pre>
<p><strong>考点：map线程安全</strong><br/>
解答：可能会出现fatal error: concurrent map read and map write. 修改一下看看效果</p>
<pre><code>func (ua *UserAges) Get(name string) int {
    ua.Lock()
    defer ua.Unlock()
    if age, ok := ua.ages[name]; ok {
        return age
    }
    return -1
}
</code></pre>
<h3>9. 下面的迭代会有什么问题？</h3>
<pre><code>func (set *threadSafeSet) Iter() &lt;-chan interface{} {
    ch := make(chan interface{})
    go func() {
        set.RLock()

        for elem := range set.s {
            ch &lt;- elem
        }

        close(ch)
        set.RUnlock()

    }()
    return ch
}
</code></pre>
<p><strong>考点：chan缓存池</strong><br/>
解答：看到这道题，我也在猜想出题者的意图在哪里。 chan?sync.RWMutex?go?chan缓存池?迭代? 所以只能再读一次题目，就从迭代入手看看。 既然是迭代就会要求set.s全部可以遍历一次。但是chan是为缓存的，那就代表这写入一次就会阻塞。 我们把代码恢复为可以运行的方式，看看效果</p>
<pre><code>package main

import (
    &#34;sync&#34;
    &#34;fmt&#34;
)

//下面的迭代会有什么问题？

type threadSafeSet struct {
    sync.RWMutex
    s []interface{}
}

func (set *threadSafeSet) Iter() &lt;-chan interface{} {
    // ch := make(chan interface{}) // 解除注释看看！
    ch := make(chan interface{},len(set.s))
    go func() {
        set.RLock()

        for elem,value := range set.s {
            ch &lt;- elem
            println(&#34;Iter:&#34;,elem,value)
        }

        close(ch)
        set.RUnlock()

    }()
    return ch
}

func main()  {

    th:=threadSafeSet{
        s:[]interface{}{&#34;1&#34;,&#34;2&#34;},
    }
    v:=&lt;-th.Iter()
    fmt.Sprintf(&#34;%s%v&#34;,&#34;ch&#34;,v)
}
</code></pre>
<h3>10. 以下代码能编译过去吗？为什么？</h3>
<pre><code>package main

import (
    &#34;fmt&#34;
)

type People interface {
    Speak(string) string
}

type Stduent struct{}

func (stu *Stduent) Speak(think string) (talk string) {
    if think == &#34;bitch&#34; {
        talk = &#34;You are a good boy&#34;
    } else {
        talk = &#34;hi&#34;
    }
    return
}

func main() {
    var peo People = Stduent{}
    think := &#34;bitch&#34;
    fmt.Println(peo.Speak(think))
}
</code></pre>
<p><strong>考点：golang的方法集</strong><br/>
解答：编译不通过！ 做错了！？说明你对golang的方法集还有一些疑问。<br/>
一句话：golang的方法集仅仅影响接口实现和方法表达式转化，与通过实例或者指针调用方法无关。</p>
<h3>11. 以下代码打印出来什么内容，说出为什么。</h3>
<pre><code>package main

import (
    &#34;fmt&#34;
)

type People interface {
    Show()
}

type Student struct{}

func (stu *Student) Show() {

}

func live() People {
    var stu *Student
    return stu
}

func main() {
    if live() == nil {
        fmt.Println(&#34;AAAAAAA&#34;)
    } else {
        fmt.Println(&#34;BBBBBBB&#34;)
    }
}
</code></pre>
<p><strong>考点：interface内部结构</strong><br/>
解答：很经典的题！ 这个考点是很多人忽略的interface内部结构。 go中的接口分为两种一种是空的接口类似这样：</p>
<pre><code>var in interface{}
</code></pre>
<p>另一种如题目：</p>
<pre><code>type People interface {
    Show()
}
</code></pre>
<p>他们的底层结构如下：</p>
<pre><code>type eface struct {      //空接口
    _type *_type         //类型信息
    data  unsafe.Pointer //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)
}
type iface struct {      //带有方法的接口
    tab  *itab           //存储type信息还有结构实现方法的集合
    data unsafe.Pointer  //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)
}
type _type struct {
    size       uintptr  //类型大小
    ptrdata    uintptr  //前缀持有所有指针的内存大小
    hash       uint32   //数据hash值
    tflag      tflag
    align      uint8    //对齐
    fieldalign uint8    //嵌入结构体时的对齐
    kind       uint8    //kind 有些枚举值kind等于0是无效的
    alg        *typeAlg //函数指针数组，类型实现的所有方法
    gcdata    *byte
    str       nameOff
    ptrToThis typeOff
}
type itab struct {
    inter  *interfacetype  //接口类型
    _type  *_type          //结构类型
    link   *itab
    bad    int32
    inhash int32
    fun    [1]uintptr      //可变大小 方法集合
}
</code></pre>
<p>可以看出iface比eface 中间多了一层itab结构。 itab 存储_type信息和[]fun方法集，从上面的结构我们就可得出，因为data指向了nil 并不代表interface 是nil， 所以返回值并不为空，这里的fun(方法集)定义了接口的接收规则，在编译的过程中需要验证是否实现接口 结果：</p>
<pre><code>BBBBBBB
</code></pre>
<p>来源:<a href="https://my.oschina.net/u/553243/blog/1478739" target="_blank" rel="nofollow">https://my.oschina.net/u/553243/blog/1478739</a></p>
<p><strong><em>添加小编微信：grey0805，加入知识分享小分队，别掉队哦！</em></strong></p>

          </div>
					</div>
					

					
					<div class="row orig-info">
						<p>本文来自：<a href="/wr?u=http://www.jianshu.com" target="_blank" title="简书">简书</a></p>
						<p>感谢作者：Chole121</p>
						<p>查看原文：<a href="/wr?u=https%3a%2f%2fwww.jianshu.com%2fp%2f4dc95dd29356" target="_blank" title="GO语言面试系列:（二）常规性Golang面试题解析">GO语言面试系列:（二）常规性Golang面试题解析</a></p>
					</div>
					
				</div>
				
				<div class="content-buttons">
					<div class="pull-right c9 f11" style="line-height: 12px; padding-top: 3px; text-shadow: 0px 1px 0px #fff;">97 次点击 &nbsp;</div>
					<a class="tb collect" href="javascript:;" title="加入收藏" data-objid="15777" data-objtype="1" data-collect="">加入收藏</a> 
					<a href="javascript:" onclick="window.open('http://service.weibo.com/share/share.php?url=https://studygolang.com/articles/15777&title='+encodeURIComponent('Go语言中文网 - GO语言面试系列:（二）常规性Golang面试题解析 by Chole121 #golang#'), '_blank', 'width=550,height=370');" class="tb">微博</a>
					<div id="content-thank">
						<a class="tb" href="javascript:;" title="赞" data-objid="15777" data-objtype="1" data-flag="">赞</a>
					</div>
				</div>
			</div>
			

			<div class="sep20"></div>
			<div class="box_white">
				<div class="cell subject">
					
					<div class="item-list">
					
						<a class="add-collection" href="javascript:"><i class="fa fa-plus"></i> 收入我的专栏</a>
					</div>
				</div>
			</div>

			<div class="sep20"></div>
			<div class="box_white">
				<div class="cell row">
					
					<div class="col-sm-6">上一篇：<a href="/articles/15776">go中defer,panic,recover详解 go中的异常处理</a></div>
					
					
					<div class="col-sm-6 right">下一篇：<a href="/articles/15778">运维监控系统之Open-Falcon</a></div>
					
				</div>
			</div>

			<div class="sep20"></div>

			
			<div id="replies" class="box_white">
				<div class="cell">
					<div class="pull-right" style="margin: -3px -5px 0px 0px;">
					
						
						
						<a href="/tag/%e9%9d%a2%e8%af%95%e9%a2%98" class="tag"><li class="fa fa-tag"></li> 面试题</a>
						
						<a href="/tag/%e4%bb%a3%e7%a0%81" class="tag"><li class="fa fa-tag"></li> 代码</a>
						
						<a href="/tag/%e4%bf%a1%e6%81%af" class="tag"><li class="fa fa-tag"></li> 信息</a>
						
						<a href="/tag/%e5%87%bd%e6%95%b0" class="tag"><li class="fa fa-tag"></li> 函数</a>
						
					
					</div>
					<span class="c9"><span class="cmtnum">0</span> 回复 </span>
				</div>
				<div class="comment-list cell" data-objid="15777" data-objtype="1" >
					<div class="words hide"><div class="text-center">暂无回复</div></div>
				</div>
			</div>

			
			
<div class="sep10"></div>
<div class="box_white page-comment">
	<input type="hidden" name="me-uid" value="0"/>
	<div class="cell">添加一条新回复
	
	<span class="h2-tip">
	（您需要 <a class="c-log" href="javascript:openPop('#login-pop');">登录</a> 后才能回复 <a href="/user/register" class="c-reg"> 没有账号</a> ？）</span>
	
	</div>
	<div class="cell">
		<div class="row clearfix md-toolbar">
			<ul class="col-md-10 list-inline comment-tab-menu" data-comment-group="default">
				<li class="comment-edit-tab cur"><a href="#" class="op">编辑</a></li>
				<li class="comment-preview-tab"><a href="#" class="op">预览</a></li>
				<li>
					<div class="nav reply-to dn" data-floor="" data-username="">
						<i class="fa fa-mail-reply" title=""></i>
						<a href="#reply" class="user" title=""></a>
						<a href="#" class="close"><i class="fa fa-close"></i></a>
					</div>
				</li>
			</ul>
			<div class="col-md-2 text-right">
				<i id="upload-img" class="glyphicon glyphicon-picture upload-img tool-tip" data-toggle="tooltip" data-placement="top" title="上传图片"></i>
			</div>
		</div>
		<div class="submit" id="commentForm">
			<div class="comment-content-text" data-comment-group="default">
				<textarea id="comment-content" name="content" class="comment-textarea main-textarea need-autogrow" rows="8"></textarea>
			</div>
			<div class="comment-content-preview cell" data-comment-group="default"></div>
			<div class="sub row">
				<ul class="help-block col-md-10">
					<li>请尽量让自己的回复能够对别人有帮助</li>
					<li class="markdown_tip">支持 Markdown 格式, <strong>**粗体**</strong>、~~删除线~~、<code>`单行代码`</code></li>
					<li>支持 @ 本站用户；支持表情（输入 : 提示），见 <a href="http://www.emoji-cheat-sheet.com/" target="_blank">Emoji cheat sheet</a></li>
					<li>图片支持拖拽、截图粘贴等方式上传</li>
				</ul>
				<div class="col-md-2 text-right"><button id="comment-submit" type="submit" title="提交" class="btn btn-default">提交</button></div>
			</div>
		</div>
	</div>
</div>

<style type="text/css">
#replies { margin-bottom: 15px; }
#replies .reply {
	margin: 0 -15px;
	padding: 15px 15px;
	position: relative;
	border-bottom: 1px solid #eee;
	padding-left: 74px;
}
#replies .reply .avatar {
	position: absolute;
	top: 15px;
	left: 15px;
}
.avatar-48 {
	width: 48px;
	height: 48px;
	border-radius: 120px;
}
.media-object {
	display: block;
}
.avatar-16 {
	width: 16px;
	height: 16px;
	border-radius: 120px;
}
#replies .reply .reply-to-block .info .media-object {
	display: inline-block;
	margin-right: 5px;
	vertical-align: top;
}
#replies .reply .reply-to-block .info {
	margin: 0;
}
#replies .reply .reply-to-block .info .user-name {
	font-weight: bold;
}
#replies .reply .reply-to-block {
	padding: 8px 15px;
	background: #f7f7f7;
	border-radius: 3px;
	margin-bottom: 10px;
}
.avatar .uface, .avatar .media-object {
	border-radius: 120px;
}
#replies .reply .infos {
	min-height: 48px;
}
#replies .reply .info {
	color: #999;
	margin-bottom: 6px;
	font-size: 12px;
}
#replies .reply .info .name {
	font-weight: bold;
	font-size: 13px;
}
#replies .reply .info .name a {
	color: #555;
}
#replies .reply .info .floor {
	color: #7AA87A;
}
#replies .reply .info a.time {
	color: #999;
	border-bottom: 1px dashed #ccc;
	text-decoration: none !important;
	cursor: pointer;
}
abbr[title] {
	border-bottom: 0px;
	cursor: pointer;
}
.opts {
	color: #666;
}
@media (min-width: 1026px) {
	#replies .reply .hideable {
		display: none;
	}
}
#replies .reply .opts a {
	display: inline-block;
	vertical-align: baseline;
	line-height: 22px;
	padding: 2px 5px;
	height: 22px;
	min-width: 22px;
	text-align: center;
}
#replies .info .opts a {
	font-size: 13px;
	margin-left: 5px;
	color: #999;
}
#replies .info .opts a.edit {
	display: none;
}
.markdown {
	position: relative;
	letter-spacing: .03em;
	font-size: 15px;
	text-overflow: ellipsis;
	word-wrap: break-word;
}
.markdown img.twemoji {
	width: 20px;
}
.markdown img {
	vertical-align: top;
	max-width: 100%;
}
.markdown p {
	font-size: 14px;
	line-height: 26px;
	margin-bottom: 0;
	color: #000;
}
.md-toolbar .reply-to {
    padding-top: 3px;
    padding-left: 8px;
}
.close {
    float: right;
    font-size: 21px;
    font-weight: 700;
    line-height: 1;
    color: #000;
    text-shadow: 0 1px 0 #fff;
    filter: alpha(opacity=20);
    opacity: .2;
}
a.close:hover {
	background-color: #d0d0d0;
    color: #666
}
.md-toolbar .reply-to .close {
    font-size: 14px;
    margin-left: 5px;
    margin-top: 1px;
}
.edit-wrapper {
	display: none;
	border: 1px solid #c0d3eb;
	padding: 8px;
	border-radius: 4px;
}

.edit-textarea {
	resize: none;
	width: 100%;
	color: #000;
	font-size: 14px;
	border: 1px solid #E5E5E5;
	padding: 5px;
}
.btn-edit {
	cursor: pointer;
}


</style>

<script type="text/x-jsrender" id="one-comment">
<div class="reply [%if is_new%]light[%/if%]" id="reply-[%:comment.floor%]">
	<div data-floor="[%:comment.floor%]">
		<div class="avatar"><a title="[%:user.username%]" href="/user/[%:user.username%]"><img class="media-object avatar-48" src="[%:user.avatar%]" alt="[%:user.username%]"></a></div>
			<div class="infos">
				<div class="info">
					<span class="name">
						<a class="user-name" data-name="[%:user.name%]" href="/user/[%:user.username%]">[%:user.username%]</a>
					</span> ·
					<span class="floor">#[%:comment.floor%]</span> ·
					<abbr class="timeago" title="[%:comment.ctime%]">[%:comment.cmt_time%]</abbr>
					<span class="opts pull-right">
						<span class="op-reply hideable">
							[%if me.uid == user.uid %]
								<a data-floor="[%:comment.floor%]" title="编辑" class="btn-edit glyphicon glyphicon-edit"></a>
							[%/if%]
						  <a data-floor="[%:comment.floor%]" data-username="[%:user.username%]" title="回复此楼" class="btn-reply fa fa-mail-reply" href="#"></a>
						</span>
						
					</span>
				</div>
				[%if comment.reply_floor > 0%]
				<div class="reply-to-block">
					<div class="info reply_user">
						对
						<a data-remote="true" href="/user/[%:comment.reply_user.username%]">
							<img class="media-object avatar-16" src="[%:comment.reply_user.avatar%]" alt="[%:comment.reply_user.username%]"><span class="user-name">[%:comment.reply_user.username%]</span>
						</a>
						<a href="#reply-[%:comment.reply_floor%]"><span class="reply-floor">#[%:comment.reply_floor%]</span></a> 回复
					</div>
					<div class="markdown dn">
						<p>[%:comment.reply_content%]</p>
					</div>
				</div>
				[%/if%]

			<div class="markdown" data-floor="[%:comment.floor%]">
				<div class="content">[%:comment.content%]</div>
				<div class="edit-wrapper">
					<div class="row clearfix md-toolbar">
						<ul class="col-md-10 list-inline comment-tab-menu" data-comment-group="[%:comment.floor%]">
								<li class="comment-edit-tab cur"><a href="#" class="op">编辑</a></li>
								<li class="comment-preview-tab"><a href="#" class="op">预览</a></li>
						</ul>
						<div class="col-md-2 text-right">
							<i data-floor="[%:comment.floor%]" class="glyphicon glyphicon-picture upload-img tool-tip" data-toggle="tooltip" data-placement="top" title="上传图片"></i>
						</div>
					</div>
					<div class="comment-content-text" data-comment-group="[%:comment.floor%]">
						<textarea data-raw-content="[%:comment.rawContent%]" name="content" class="comment-textarea" rows="8" style="width: 100%;">[%:comment.rawContent%]</textarea>
					</div>
					<div class="comment-content-preview cell" data-comment-group="[%:comment.floor%]"></div>
					<div class="text-right">
						<button type="submit" title="提交" data-cid="[%:comment.cid%]" data-floor="[%:comment.floor%]" class="submit btn btn-default">提交</button>
						<button title="取消" data-floor="[%:comment.floor%]" class="cancel btn btn-default">取消</button>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>
</script>


			

			
		</div>
	</div>
	<div class="col-md-3 col-sm-6">
		<div class="sep20"></div>
		<div class="box_white sidebar">
	
	<div class="top">
		<h3 class="title"><i class="glyphicon glyphicon-user"></i> 用户登录</h3>
	</div>
	<div class="sb-content inner_content" style="padding-bottom: 0;">
		<form action="/account/login" method="post" class="form-horizontal login" role="form" style="padding-top: 0; padding-bottom: 0;">
			<div class="form-group">
				<div class="col-sm-10">
					<input type="text" class="form-control input-sm" id="username" name="username" placeholder="请填写用户名或邮箱">
				</div>
			</div>
			<div class="form-group">
				<div class="col-sm-10">
					<input type="password" class="form-control input-sm" id="passwd" name="passwd" placeholder="请填写密码">
				</div>
			</div>
			<div class="form-group">
				<div class="col-sm-10">
					<div class="checkbox">
						<label>
							<input id="user_remember_me" name="remember_me" type="checkbox" value="1" checked="checked" />	记住登录状态
						</label>
						<input class="btn btn-default btn-sm" data-disable-with="正在登录" name="commit" type="submit" value="登录" />
					</div>
					<div class="sep10"></div>
					<a href="/oauth/github/login" class="btn btn-default btn-sm">
						<i class="fa fa-github" aria-hidden="true"></i>
						GitHub 登录
					</a>
				</div>
			</div>
		</form>
	</div>
	
</div>





		
		<div class="box_white sidebar" id="ad-right1">
			
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-4512014793067058"
     data-ad-slot="4230018468"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			
		</div>
		

		<div class="box_white sidebar">
	<div class="top">
		<h3 class="title"><i class="glyphicon glyphicon-stats"></i>&nbsp;今日阅读排行</h3>
	</div>
	<div class="sb-content">
		<div class="rank-list" data-objtype="1" data-limit="10" data-rank_type="today">
			<ul class="list-unstyled">
				<img src="/static/img/loaders/loader7.gif" alt="加载中" />
			</ul>
		</div>
	</div>
</div>
		
		
		<div class="box_white sidebar" id="ad-right2">
			
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 侧边栏自适应 -->
<ins class="adsbygoogle"
     style="display:inline-block;min-width:270px;max-width:970px;width:100%;height:290px"
     data-ad-client="ca-pub-4512014793067058"
     data-ad-slot="3487838313"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			
		</div>
		

		<div class="box_white sidebar">
	<div class="top">
		<h3 class="title"><i class="glyphicon glyphicon-stats"></i>&nbsp;一周阅读排行</h3>
	</div>
	<div class="sb-content">
		<div class="rank-list" data-objtype="1" data-limit="10" data-rank_type="week">
			<ul class="list-unstyled">
				<img src="/static/img/loaders/loader7.gif" alt="加载中" />
			</ul>
		</div>
	</div>
</div>
		
	</div>
</div>

<link rel="stylesheet" href="https://static.studygolang.com/static/dist/css/modal.min.css?v=0.1">
<div class="modal contribute-modal animated" style="display: none;">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close">×</button>
                <h4 class="modal-title">
                    给该专栏投稿
                    <a href="/articles/new" class="new-note-btn">写篇新文章</a>
                </h4>
                <span class="notice">每篇文章有总共有 5 次投稿机会</span>
                <div>
                    <input type="text" placeholder="搜索我的文章" class="search-input">
                    <a class="search-btn">
                        <i class="fa fa-search" aria-hidden="true" style="margin: 8px -1px 0 0;display: block;"></i>
                    </a>
                </div>
            </div>
            <div class="modal-body">
                <ul id="contribute-note-list"></ul>
                <div class="modal-notes-placeholder" style="display: none;">
                    <div class="text"></div>
                    <div class="btn"></div>
                </div>
            </div>
            <div class="modal-footer"></div>
        </div>
    </div>
</div>


<div class="modal animated add-self" style="display: none;">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" data-dismiss="modal" class="close">×</button>
                <h4 class="modal-title">收入到我管理的专栏
                    <span class="new-collection-btn"><a href="/subject/new" target="_blank">新建专栏</a></span>
                </h4>
            </div>
            <div class="modal-body">
                <div class="search">
                    <input type="search" name="search-self" placeholder="搜索我管理的专栏">
                    <a class="search-btn">
                        <i class="fa fa-search" aria-hidden="true" style="margin: 6px 1px 0 0;display: block;"></i>
                    </a>
                </div>
                <ul id="self-note-list"></ul>
                <div class="modal-collections-placeholder" style="display: none;">
                    <div class="avatar"></div>
                    <div class="wrap">
                        <div class="btn"></div>
                        <div class="name"></div>
                        <div class="text"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer"></div>
        </div>
    </div>
</div>



<template id="content_tpl">
<div class="show-content-free">
            <p>最近在很多地方看到了<a href="https://zhuanlan.zhihu.com/p/26972862" target="_blank" rel="nofollow">golang的面试题</a>，看到了很多人对Golang的面试题心存恐惧，也是为了复习基础，我把解题的过程总结下来。</p>
<h1>面试题</h1>
<h2>1. 写出下面代码输出内容。</h2>
<pre><code>package main

import (
    &#34;fmt&#34;
)

func main() {
    defer_call()
}

func defer_call() {
    defer func() { fmt.Println(&#34;打印前&#34;) }()
    defer func() { fmt.Println(&#34;打印中&#34;) }()
    defer func() { fmt.Println(&#34;打印后&#34;) }()

    panic(&#34;触发异常&#34;)
}
</code></pre>
<p><strong>考点：defer执行顺序</strong><br/>
解答：defer 是后进先出。panic 需要等defer 结束后才会向上传递。<br/>
出现panic恐慌时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。</p>
<pre><code>打印后
打印中
打印前
panic: 触发异常
</code></pre>
<p>近期有同学遇到多次执行的时候发现panic的执行顺序不定，那么是不是因为panic与defer没有先后关系呢？我们先来下面的例子：</p>
<pre><code>func main() {
    defer_call()
}

func defer_call() {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println(&#34;one=&#34;, err)
        }
    }()
    defer func() { fmt.Println(&#34;打印前&#34;) }()
    defer func() { fmt.Println(&#34;打印中&#34;) }()
    defer func() { fmt.Println(&#34;打印后&#34;) }()

    panic(&#34;触发异常&#34;)

}
</code></pre>
<p>大家再多次执行，看看是否都是输出：</p>
<pre><code>打印后
打印中
打印前
one= 触发异常
</code></pre>
<p>那为什么没有加recover()时候，panic执行顺序不定呢？<br/>
defer的执行顺序肯定是FILO的，但是没有被recover的panic协程（线程）可能争夺CPU的顺序比defer快，所以造成了这样的情况，也可能是写缓存问题，所以对panic进行recover将其加入到defer队列中。</p>
<h2>2. 以下代码有什么问题，说明原因。</h2>
<pre><code>type student struct {
    Name string
    Age  int
}

func pase_student() {
    m := make(map[string]*student)
    stus := []student{
        {Name: &#34;zhou&#34;, Age: 24},
        {Name: &#34;li&#34;, Age: 23},
        {Name: &#34;wang&#34;, Age: 22},
    }
    for _, stu := range stus {
        m[stu.Name] = &amp;stu
    }

}
</code></pre>
<p><strong>考点：foreach</strong><br/>
解答：这样的写法初学者经常会遇到的，很危险！<br/>
与Java的foreach一样，都是使用副本的方式。所以m[stu.Name]=&amp;stu实际上一致指向同一个指针， 最终该指针的值为遍历的最后一个struct的值拷贝。 就像想修改切片元素的属性：</p>
<pre><code>for _, stu := range stus {
    stu.Age = stu.Age+10
}
</code></pre>
<p>也是不可行的。 大家可以试试打印出来：</p>
<pre><code>func pase_student() {
    m := make(map[string]*student)
    stus := []student{
        {Name: &#34;zhou&#34;, Age: 24},
        {Name: &#34;li&#34;, Age: 23},
        {Name: &#34;wang&#34;, Age: 22},
    }
    // 错误写法
    for _, stu := range stus {
        m[stu.Name] = &amp;stu
    }

    for k,v:=range m{
        println(k,&#34;=&gt;&#34;,v.Name)
    }

    // 正确
    for i:=0;i&lt;len(stus);i++  {
        m[stus[i].Name] = &amp;stus[i]
    }
    for k,v:=range m{
        println(k,&#34;=&gt;&#34;,v.Name)
    }
}
</code></pre>
<h3>3. 下面的代码会输出什么，并说明原因</h3>
<pre><code>func main() {
    runtime.GOMAXPROCS(1)
    wg := sync.WaitGroup{}
    wg.Add(20)
    for i := 0; i &lt; 10; i++ {
        go func() {
            fmt.Println(&#34;A: &#34;, i)
            wg.Done()
        }()
    }
    for i := 0; i &lt; 10; i++ {
        go func(i int) {
            fmt.Println(&#34;B: &#34;, i)
            wg.Done()
        }(i)
    }
    wg.Wait()
}
</code></pre>
<p><strong>考点：go执行的随机性和闭包</strong><br/>
解答：谁也不知道执行后打印的顺序是什么样的，所以只能说是随机数字。<br/>
但是A:均为输出10，B:从0~9输出(顺序不定)。 第一个go func中i是外部for的一个变量，地址不变化。遍历完成后，最终i=10。 故go func执行时，i的值始终是10。</p>
<p>第二个go func中i是函数参数，与外部for中的i完全是两个变量。 尾部(i)将发生值拷贝，go func内部指向值拷贝地址。</p>
<h3>4. 下面代码会输出什么？</h3>
<pre><code>type People struct{}

func (p *People) ShowA() {
    fmt.Println(&#34;showA&#34;)
    p.ShowB()
}
func (p *People) ShowB() {
    fmt.Println(&#34;showB&#34;)
}

type Teacher struct {
    People
}

func (t *Teacher) ShowB() {
    fmt.Println(&#34;teacher showB&#34;)
}

func main() {
    t := Teacher{}
    t.ShowA()
}
</code></pre>
<p><strong>考点：go的组合继承</strong><br/>
解答：这是Golang的组合模式，可以实现OOP的继承。 被组合的类型People所包含的方法虽然升级成了外部类型Teacher这个组合类型的方法（一定要是匿名字段），但它们的方法(ShowA())调用时接受者并没有发生变化。 此时People类型并不知道自己会被什么类型组合，当然也就无法调用方法时去使用未知的组合者Teacher类型的功能。</p>
<pre><code>showA
showB
</code></pre>
<h3>5. 下面代码会触发异常吗？请详细说明</h3>
<pre><code>func main() {
    runtime.GOMAXPROCS(1)
    int_chan := make(chan int, 1)
    string_chan := make(chan string, 1)
    int_chan &lt;- 1
    string_chan &lt;- &#34;hello&#34;
    select {
    case value := &lt;-int_chan:
        fmt.Println(value)
    case value := &lt;-string_chan:
        panic(value)
    }
}
</code></pre>
<p><strong>考点：select随机性</strong><br/>
解答：select会随机选择一个可用通用做收发操作。 所以代码是有肯触发异常，也有可能不会。<br/>
单个chan如果无缓冲时，将会阻塞。但结合 select可以在多个chan间等待执行。有三点原则：</p>
<ul>
<li>select 中只要有一个case能return，则立刻执行。</li>
<li>当如果同一时间有多个case均能return则伪随机方式抽取任意一个执行。</li>
<li>如果没有一个case能return则可以执行”default”块。</li>
</ul>
<h3>6. 下面代码输出什么？</h3>
<pre><code>func calc(index string, a, b int) int {
    ret := a + b
    fmt.Println(index, a, b, ret)
    return ret
}

func main() {
    a := 1
    b := 2
    defer calc(&#34;1&#34;, a, calc(&#34;10&#34;, a, b))
    a = 0
    defer calc(&#34;2&#34;, a, calc(&#34;20&#34;, a, b))
    b = 1
}
</code></pre>
<p><strong>考点：defer执行顺序</strong><br/>
解答：<br/>
这道题类似第1题 需要注意到defer执行顺序和值传递 index:1肯定是最后执行的，但是index:1的第三个参数是一个函数，所以最先被调用calc(“10”,1,2)==&gt;10,1,2,3 执行index:2时,与之前一样，需要先调用calc(“20”,0,2)==&gt;20,0,2,2 执行到b=1时候开始调用，index:2==&gt;calc(“2”,0,2)==&gt;2,0,2,2 最后执行index:1==&gt;calc(“1”,1,3)==&gt;1,1,3,4</p>
<pre><code>10 1 2 3
20 0 2 2
2 0 2 2
1 1 3 4
</code></pre>
<h3>7. 请写出以下输入内容</h3>
<pre><code>func main() {
    s := make([]int, 5)
    s = append(s, 1, 2, 3)
    fmt.Println(s)
}
</code></pre>
<p><strong>考点：make默认值和append</strong><br/>
解答：make初始化是由默认值的哦，此处默认值为0</p>
<pre><code>[0 0 0 0 0 1 2 3]
</code></pre>
<p>大家试试改为:</p>
<pre><code>s := make([]int, 0)
s = append(s, 1, 2, 3)
fmt.Println(s)//[1 2 3]
</code></pre>
<h3>8. 下面的代码有什么问题?</h3>
<pre><code>type UserAges struct {
    ages map[string]int
    sync.Mutex
}

func (ua *UserAges) Add(name string, age int) {
    ua.Lock()
    defer ua.Unlock()
    ua.ages[name] = age
}

func (ua *UserAges) Get(name string) int {
    if age, ok := ua.ages[name]; ok {
        return age
    }
    return -1
}
</code></pre>
<p><strong>考点：map线程安全</strong><br/>
解答：可能会出现fatal error: concurrent map read and map write. 修改一下看看效果</p>
<pre><code>func (ua *UserAges) Get(name string) int {
    ua.Lock()
    defer ua.Unlock()
    if age, ok := ua.ages[name]; ok {
        return age
    }
    return -1
}
</code></pre>
<h3>9. 下面的迭代会有什么问题？</h3>
<pre><code>func (set *threadSafeSet) Iter() &lt;-chan interface{} {
    ch := make(chan interface{})
    go func() {
        set.RLock()

        for elem := range set.s {
            ch &lt;- elem
        }

        close(ch)
        set.RUnlock()

    }()
    return ch
}
</code></pre>
<p><strong>考点：chan缓存池</strong><br/>
解答：看到这道题，我也在猜想出题者的意图在哪里。 chan?sync.RWMutex?go?chan缓存池?迭代? 所以只能再读一次题目，就从迭代入手看看。 既然是迭代就会要求set.s全部可以遍历一次。但是chan是为缓存的，那就代表这写入一次就会阻塞。 我们把代码恢复为可以运行的方式，看看效果</p>
<pre><code>package main

import (
    &#34;sync&#34;
    &#34;fmt&#34;
)

//下面的迭代会有什么问题？

type threadSafeSet struct {
    sync.RWMutex
    s []interface{}
}

func (set *threadSafeSet) Iter() &lt;-chan interface{} {
    // ch := make(chan interface{}) // 解除注释看看！
    ch := make(chan interface{},len(set.s))
    go func() {
        set.RLock()

        for elem,value := range set.s {
            ch &lt;- elem
            println(&#34;Iter:&#34;,elem,value)
        }

        close(ch)
        set.RUnlock()

    }()
    return ch
}

func main()  {

    th:=threadSafeSet{
        s:[]interface{}{&#34;1&#34;,&#34;2&#34;},
    }
    v:=&lt;-th.Iter()
    fmt.Sprintf(&#34;%s%v&#34;,&#34;ch&#34;,v)
}
</code></pre>
<h3>10. 以下代码能编译过去吗？为什么？</h3>
<pre><code>package main

import (
    &#34;fmt&#34;
)

type People interface {
    Speak(string) string
}

type Stduent struct{}

func (stu *Stduent) Speak(think string) (talk string) {
    if think == &#34;bitch&#34; {
        talk = &#34;You are a good boy&#34;
    } else {
        talk = &#34;hi&#34;
    }
    return
}

func main() {
    var peo People = Stduent{}
    think := &#34;bitch&#34;
    fmt.Println(peo.Speak(think))
}
</code></pre>
<p><strong>考点：golang的方法集</strong><br/>
解答：编译不通过！ 做错了！？说明你对golang的方法集还有一些疑问。<br/>
一句话：golang的方法集仅仅影响接口实现和方法表达式转化，与通过实例或者指针调用方法无关。</p>
<h3>11. 以下代码打印出来什么内容，说出为什么。</h3>
<pre><code>package main

import (
    &#34;fmt&#34;
)

type People interface {
    Show()
}

type Student struct{}

func (stu *Student) Show() {

}

func live() People {
    var stu *Student
    return stu
}

func main() {
    if live() == nil {
        fmt.Println(&#34;AAAAAAA&#34;)
    } else {
        fmt.Println(&#34;BBBBBBB&#34;)
    }
}
</code></pre>
<p><strong>考点：interface内部结构</strong><br/>
解答：很经典的题！ 这个考点是很多人忽略的interface内部结构。 go中的接口分为两种一种是空的接口类似这样：</p>
<pre><code>var in interface{}
</code></pre>
<p>另一种如题目：</p>
<pre><code>type People interface {
    Show()
}
</code></pre>
<p>他们的底层结构如下：</p>
<pre><code>type eface struct {      //空接口
    _type *_type         //类型信息
    data  unsafe.Pointer //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)
}
type iface struct {      //带有方法的接口
    tab  *itab           //存储type信息还有结构实现方法的集合
    data unsafe.Pointer  //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)
}
type _type struct {
    size       uintptr  //类型大小
    ptrdata    uintptr  //前缀持有所有指针的内存大小
    hash       uint32   //数据hash值
    tflag      tflag
    align      uint8    //对齐
    fieldalign uint8    //嵌入结构体时的对齐
    kind       uint8    //kind 有些枚举值kind等于0是无效的
    alg        *typeAlg //函数指针数组，类型实现的所有方法
    gcdata    *byte
    str       nameOff
    ptrToThis typeOff
}
type itab struct {
    inter  *interfacetype  //接口类型
    _type  *_type          //结构类型
    link   *itab
    bad    int32
    inhash int32
    fun    [1]uintptr      //可变大小 方法集合
}
</code></pre>
<p>可以看出iface比eface 中间多了一层itab结构。 itab 存储_type信息和[]fun方法集，从上面的结构我们就可得出，因为data指向了nil 并不代表interface 是nil， 所以返回值并不为空，这里的fun(方法集)定义了接口的接收规则，在编译的过程中需要验证是否实现接口 结果：</p>
<pre><code>BBBBBBB
</code></pre>
<p>来源:<a href="https://my.oschina.net/u/553243/blog/1478739" target="_blank" rel="nofollow">https://my.oschina.net/u/553243/blog/1478739</a></p>
<p><strong><em>添加小编微信：grey0805，加入知识分享小分队，别掉队哦！</em></strong></p>

          </div>
</template>



		</div>
	</div>
	<div class="sep10"></div>
	<footer id="bottom">
		<div class="container nav-content">
			<div class="inner_content">
				<div class="sep10"></div>   
				<strong>
					
					<a href="/wiki/about" class="dark">关于</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/faq" class="dark">FAQ</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/contributors" class="dark">贡献者</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/go/feedback" class="dark">反馈</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://github.com/studygolang" class="dark">Github</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="http://weibo.com/studygolang" class="dark">新浪微博</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://play.studygolang.com" class="dark">Play</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/duty" class="dark">免责声明</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/contact" class="dark">联系我们</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/donate" class="dark">捐赠</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/cool" class="dark">酷站</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/feed.html" class="dark">Feed订阅</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<span id="onlineusers">1502</span> 人在线
				</strong>
				&nbsp;<span class="cc">最高记录 <span id="maxonline">2928</span></span>
				<div class="sep20"></div>
				&copy;2013-2018 studygolang.com Go语言中文网，中国 Golang 社区，致力于构建完善的 Golang 中文社区，Go语言爱好者的学习家园。
				<div class="sep5"></div>
				Powered by <a href="https://github.com/studygolang/studygolang">StudyGolang(Golang + MySQL)</a> &nbsp;<span class="snow">•</span>&nbsp;<span class="snow">·</span>&nbsp;CDN 采用 <a href="https://portal.qiniu.com/signup?code=3lfz4at7pxfma" title="七牛云" class="dark" target="_blank">七牛云</a>
				<div class="sep20"></div>
				<span class="small cc">VERSION: V3.5.0&nbsp;<span class="snow">·</span>&nbsp;171.372575ms&nbsp;<span class="snow">·</span>&nbsp;<strong>为了更好的体验，本站推荐使用 Chrome 或 Firefox 浏览器</strong></span>
				<div class="sep20"></div>
				<span class="f12 c9"><a href="http://www.miibeian.gov.cn/" target="_blank" rel="nofollow">京ICP备14030343号-1</a></span>
				<div class="sep10"></div>
			</div>
		</div>
	</footer>

	<div id="gotop"></div>

	
	<input type="hidden" id="is_login_status" value="0" />
	<div class="pop login-pop" id="login-pop">
		<div style="position: relative;"><span class="close" style="position: absolute; right: -15px; top: -15px; cursor: pointer; color: #000; font-size: 13px;">X</span></div>
		<div class="login-form">
			<div class="error text-center"></div>
			<div class="text-center" style="margin-bottom: 5px;">登录和大家一起探讨吧</div>
			<form action="#" method="post" class="form-horizontal" role="form">
				<div class="form-group">
					<label for="username" class="col-sm-3 control-label">用户名</label>
					<div class="col-sm-9 form-input">
						<input type="text" class="form-control" id="form_username" name="username" placeholder="请填写用户名或邮箱">
					</div>
				</div>
				<div class="form-group">
					<label for="passwd" class="col-sm-3 control-label">密码</label>
					<div class="col-sm-9 form-input">
						<input type="password" class="form-control" id="form_passwd" name="passwd" placeholder="密码">
					</div>
				</div>
				<div class="form-group">
					<div class="col-sm-offset-2 col-sm-10">
						<div class="checkbox">
							<label>
								<input id="user_remember_me" name="remember_me" type="checkbox" value="1" checked="checked" />	记住登录状态
							</label>
							<button type="submit" id="login-btn" class="btn btn-default btn-sm">登录</button>
						</div>
					</div>
				</div>
				<div class="form-group">
					<div class="col-sm-offset-2 col-sm-10">
						<a id="login-github" href="/oauth/github/login" class="btn btn-default btn-sm pull-left">
							<i class="fa fa-github" aria-hidden="true"></i>
							GitHub 登录
						</a>
						<div class="forget">
							<a href="/account/forgetpwd" title="点击找回密码">忘记密码？</a>
						</div>
						<div class="register">
							<span>还不是会员</span><a href="/account/register">现在注册</a>
						</div>
					</div>
				</div>
			</form>
		</div>
	</div>
	<div id="sg-overlay"></div>
	
	
	<script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
	<script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
	<script src="https://cdn.staticfile.org/jquery-timeago/1.6.1/jquery.timeago.min.js"></script>
	<script src="https://cdn.staticfile.org/zoom.js/0.0.1/zoom.min.js"></script>
	<script src="https://cdn.staticfile.org/marked/0.3.6/marked.min.js"></script>
	<script src="https://cdn.staticfile.org/Caret.js/0.3.1/jquery.caret.min.js"></script>
	<script src="https://cdn.staticfile.org/emojify.js/1.1.0/js/emojify.min.js"></script>

	<script type="text/javascript">
	var uid =  0 ;
	var isHttps =  true ,
		cdnDomain = "https:\/\/static.studygolang.com\/";
	if (isHttps) {
		var wsUrl = 'wss://studygolang.com/ws?uid='+uid;
	} else {
		var wsUrl = 'ws://studygolang.com/ws?uid='+uid;
	}
	var GLaunchTime =  1540036286 *1000;
	</script>
	<script src="https://cdn.staticfile.org/lscache/1.1.0/lscache.min.js"></script>
	<script src="https://cdn.staticfile.org/jsrender/0.9.90/jsrender.min.js"></script>
	<script src="https://cdn.staticfile.org/plupload/3.1.1/plupload.full.min.js"></script>
	<script type="text/javascript">
	$.views.settings.delimiters("[%", "%]");
	
	</script>

	<script src="https://static.studygolang.com/static/dist/js/sg_libs.min.js"></script>
	<script src="https://static.studygolang.com/static/dist/js/sg_base.min.js?v=0.4"></script>

	

<script type="text/javascript" src="https://static.studygolang.com/static/dist/js/articles.min.js"></script>

<script type="text/javascript">

SG.SIDE_BARS = [
	"/rank/view",
];

var keyprefix = 'article';
var objid =  15777 ;

$(function(){
	
	
	
	$('.need-autogrow').autoGrow();
	
	loadComments();

	
	$('#wrapper .content').on('mousedown', 'a', function(evt){
		var url = $(this).attr('href');
		
		$(this).attr('href', url);
		$(this).attr('target', '_blank');
	});

	var len = '最近在很多地方看到了golang的面试题，看到了很多人对Golang的面试题心存恐惧，也是为了复习基础，我把解题的过程总结下来。 面试题 1. 写出下面代码输出内容。 package main import ( \x22fmt\x22 ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(\x22打印前\x22) }() defer func() { fmt.Println(\x22打印中\x22) }() defer func() { fmt.Println(\x22打印后\x22) }() panic(\x22触发异常\x22) } 考点：defer执行顺序 解答：defer 是后进先出。panic 需要等defer 结束后才会向上传递。 出现panic恐慌时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。 打印后 打印中 打印前 panic: 触发异常 近期有同学遇到多次执行的时候发现panic的执行顺序不定，那么是不是因为panic与defer没有先后关系呢？我们先来下面的例子： func main() { defer_call() } func defer_call() { defer func() { if err := recover(); err != nil { fmt.Println(\x22one=\x22, err) } }() defer func() { fmt.Println(\x22打印前\x22) }() defer func() { fmt.Println(\x22打印中\x22) }() defer func() { fmt.Println(\x22打印后\x22) }() panic(\x22触发异常\x22) } 大家再多次执行，看看是否都是输出： 打印后 打印中 打印前 one= 触发异常 那为什么没有加recover()时候，panic执行顺序不定呢？ defer的执行顺序肯定是FILO的，但是没有被recover的panic协程（线程）可能争夺CPU的顺序比defer快，所以造成了这样的情况，也可能是写缓存问题，所以对panic进行recover将其加入到defer队列中。 2. 以下代码有什么问题，说明原因。 type student struct { Name string Age int } func pase_student() { m := make(map[string]*student) stus := []student{ {Name: \x22zhou\x22, Age: 24}, {Name: \x22li\x22, Age: 23}, {Name: \x22wang\x22, Age: 22}, } for _, stu := range stus { m[stu.Name] = \x26stu } } 考点：foreach 解答：这样的写法初学者经常会遇到的，很危险！ 与Java的foreach一样，都是使用副本的方式。所以m[stu.Name]=\x26stu实际上一致指向同一个指针， 最终该指针的值为遍历的最后一个struct的值拷贝。 就像想修改切片元素的属性： for _, stu := range stus { stu.Age = stu.Age\x2b10 } 也是不可行的。 大家可以试试打印出来： func pase_student() { m := make(map[string]*student) stus := []student{ {Name: \x22zhou\x22, Age: 24}, {Name: \x22li\x22, Age: 23}, {Name: \x22wang\x22, Age: 22}, } \/\/ 错误写法 for _, stu := range stus { m[stu.Name] = \x26stu } for k,v:=range m{ println(k,\x22=\x3e\x22,v.Name) } \/\/ 正确 for i:=0;i\x3clen(stus);i\x2b\x2b { m[stus[i].Name] = \x26stus[i] } for k,v:=range m{ println(k,\x22=\x3e\x22,v.Name) } } 3. 下面的代码会输出什么，并说明原因 func main() { runtime.GOMAXPROCS(1) wg := sync.WaitGroup{} wg.Add(20) for i := 0; i \x3c 10; i\x2b\x2b { go func() { fmt.Println(\x22A: \x22, i) wg.Done() }() } for i := 0; i \x3c 10; i\x2b\x2b { go func(i int) { fmt.Println(\x22B: \x22, i) wg.Done() }(i) } wg.Wait() } 考点：go执行的随机性和闭包 解答：谁也不知道执行后打印的顺序是什么样的，所以只能说是随机数字。 但是A:均为输出10，B:从0~9输出(顺序不定)。 第一个go func中i是外部for的一个变量，地址不变化。遍历完成后，最终i=10。 故go func执行时，i的值始终是10。 第二个go func中i是函数参数，与外部for中的i完全是两个变量。 尾部(i)将发生值拷贝，go func内部指向值拷贝地址。 4. 下面代码会输出什么？ type People struct{} func (p *People) ShowA() { fmt.Println(\x22showA\x22) p.ShowB() } func (p *People) ShowB() { fmt.Println(\x22showB\x22) } type Teacher struct { People } func (t *Teacher) ShowB() { fmt.Println(\x22teacher showB\x22) } func main() { t := Teacher{} t.ShowA() } 考点：go的组合继承 解答：这是Golang的组合模式，可以实现OOP的继承。 被组合的类型People所包含的方法虽然升级成了外部类型Teacher这个组合类型的方法（一定要是匿名字段），但它们的方法(ShowA())调用时接受者并没有发生变化。 此时People类型并不知道自己会被什么类型组合，当然也就无法调用方法时去使用未知的组合者Teacher类型的功能。 showA showB 5. 下面代码会触发异常吗？请详细说明 func main() { runtime.GOMAXPROCS(1) int_chan := make(chan int, 1) string_chan := make(chan string, 1) int_chan \x3c- 1 string_chan \x3c- \x22hello\x22 select { case value := \x3c-int_chan: fmt.Println(value) case value := \x3c-string_chan: panic(value) } } 考点：select随机性 解答：select会随机选择一个可用通用做收发操作。 所以代码是有肯触发异常，也有可能不会。 单个chan如果无缓冲时，将会阻塞。但结合 select可以在多个chan间等待执行。有三点原则： select 中只要有一个case能return，则立刻执行。 当如果同一时间有多个case均能return则伪随机方式抽取任意一个执行。 如果没有一个case能return则可以执行”default”块。 6. 下面代码输出什么？ func calc(index string, a, b int) int { ret := a \x2b b fmt.Println(index, a, b, ret) return ret } func main() { a := 1 b := 2 defer calc(\x221\x22, a, calc(\x2210\x22, a, b)) a = 0 defer calc(\x222\x22, a, calc(\x2220\x22, a, b)) b = 1 } 考点：defer执行顺序 解答： 这道题类似第1题 需要注意到defer执行顺序和值传递 index:1肯定是最后执行的，但是index:1的第三个参数是一个函数，所以最先被调用calc(“10”,1,2)==\x3e10,1,2,3 执行index:2时,与之前一样，需要先调用calc(“20”,0,2)==\x3e20,0,2,2 执行到b=1时候开始调用，index:2==\x3ecalc(“2”,0,2)==\x3e2,0,2,2 最后执行index:1==\x3ecalc(“1”,1,3)==\x3e1,1,3,4 10 1 2 3 20 0 2 2 2 0 2 2 1 1 3 4 7. 请写出以下输入内容 func main() { s := make([]int, 5) s = append(s, 1, 2, 3) fmt.Println(s) } 考点：make默认值和append 解答：make初始化是由默认值的哦，此处默认值为0 [0 0 0 0 0 1 2 3] 大家试试改为: s := make([]int, 0) s = append(s, 1, 2, 3) fmt.Println(s)\/\/[1 2 3] 8. 下面的代码有什么问题? type UserAges struct { ages map[string]int sync.Mutex } func (ua *UserAges) Add(name string, age int) { ua.Lock() defer ua.Unlock() ua.ages[name] = age } func (ua *UserAges) Get(name string) int { if age, ok := ua.ages[name]; ok { return age } return -1 } 考点：map线程安全 解答：可能会出现fatal error: concurrent map read and map write. 修改一下看看效果 func (ua *UserAges) Get(name string) int { ua.Lock() defer ua.Unlock() if age, ok := ua.ages[name]; ok { return age } return -1 } 9. 下面的迭代会有什么问题？ func (set *threadSafeSet) Iter() \x3c-chan interface{} { ch := make(chan interface{}) go func() { set.RLock() for elem := range set.s { ch \x3c- elem } close(ch) set.RUnlock() }() return ch } 考点：chan缓存池 解答：看到这道题，我也在猜想出题者的意图在哪里。 chan?sync.RWMutex?go?chan缓存池?迭代? 所以只能再读一次题目，就从迭代入手看看。 既然是迭代就会要求set.s全部可以遍历一次。但是chan是为缓存的，那就代表这写入一次就会阻塞。 我们把代码恢复为可以运行的方式，看看效果 package main import ( \x22sync\x22 \x22fmt\x22 ) \/\/下面的迭代会有什么问题？ type threadSafeSet struct { sync.RWMutex s []interface{} } func (set *threadSafeSet) Iter() \x3c-chan interface{} { \/\/ ch := make(chan interface{}) \/\/ 解除注释看看！ ch := make(chan interface{},len(set.s)) go func() { set.RLock() for elem,value := range set.s { ch \x3c- elem println(\x22Iter:\x22,elem,value) } close(ch) set.RUnlock() }() return ch } func main() { th:=threadSafeSet{ s:[]interface{}{\x221\x22,\x222\x22}, } v:=\x3c-th.Iter() fmt.Sprintf(\x22%s%v\x22,\x22ch\x22,v) } 10. 以下代码能编译过去吗？为什么？ package main import ( \x22fmt\x22 ) type People interface { Speak(string) string } type Stduent struct{} func (stu *Stduent) Speak(think string) (talk string) { if think == \x22bitch\x22 { talk = \x22You are a good boy\x22 } else { talk = \x22hi\x22 } return } func main() { var peo People = Stduent{} think := \x22bitch\x22 fmt.Println(peo.Speak(think)) } 考点：golang的方法集 解答：编译不通过！ 做错了！？说明你对golang的方法集还有一些疑问。 一句话：golang的方法集仅仅影响接口实现和方法表达式转化，与通过实例或者指针调用方法无关。 11. 以下代码打印出来什么内容，说出为什么。 package main import ( \x22fmt\x22 ) type People interface { Show() } type Student struct{} func (stu *Student) Show() { } func live() People { var stu *Student return stu } func main() { if live() == nil { fmt.Println(\x22AAAAAAA\x22) } else { fmt.Println(\x22BBBBBBB\x22) } } 考点：interface内部结构 解答：很经典的题！ 这个考点是很多人忽略的interface内部结构。 go中的接口分为两种一种是空的接口类似这样： var in interface{} 另一种如题目： type People interface { Show() } 他们的底层结构如下： type eface struct { \/\/空接口 _type *_type \/\/类型信息 data unsafe.Pointer \/\/指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*) } type iface struct { \/\/带有方法的接口 tab *itab \/\/存储type信息还有结构实现方法的集合 data unsafe.Pointer \/\/指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*) } type _type struct { size uintptr \/\/类型大小 ptrdata uintptr \/\/前缀持有所有指针的内存大小 hash uint32 \/\/数据hash值 tflag tflag align uint8 \/\/对齐 fieldalign uint8 \/\/嵌入结构体时的对齐 kind uint8 \/\/kind 有些枚举值kind等于0是无效的 alg *typeAlg \/\/函数指针数组，类型实现的所有方法 gcdata *byte str nameOff ptrToThis typeOff } type itab struct { inter *interfacetype \/\/接口类型 _type *_type \/\/结构类型 link *itab bad int32 inhash int32 fun [1]uintptr \/\/可变大小 方法集合 } 可以看出iface比eface 中间多了一层itab结构。 itab 存储_type信息和[]fun方法集，从上面的结构我们就可得出，因为data指向了nil 并不代表interface 是nil， 所以返回值并不为空，这里的fun(方法集)定义了接口的接收规则，在编译的过程中需要验证是否实现接口 结果： BBBBBBB 来源:https:\/\/my.oschina.net\/u\/553243\/blog\/1478739 添加小编微信：grey0805，加入知识分享小分队，别掉队哦！'.length;
	var readTime = Math.round(len / 900);
	if (readTime >= 1) {
		$('.read-time').text('预计阅读时间 '+readTime+' 分钟');
	} else {
		$('.read-time').text('预计阅读时间不到 1 分钟');
	}
});
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/ckeditor/4.6.2/ckeditor.js"></script>
<script type="text/javascript" src="https://static.studygolang.com/static/ckeditor/config.js"></script>
<script type="text/javascript" src="https://static.studygolang.com/static/ckeditor/article.js"></script>


<script type="text/javascript">
$(function(){
	$('code[class*="language-"]').parent('pre').addClass('line-numbers');
});
</script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/prism.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/components/prism-go.min.js"></script>
<script src="https://cdn.staticfile.org/prism/1.9.0/components/prism-json.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/components/prism-bash.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/components/prism-python.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/components/prism-nasm.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/components/prism-yaml.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/plugins/line-numbers/prism-line-numbers.min.js"></script>

<script type="text/javascript">
Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.text = Prism.languages.go;
Prism.languages.golang = Prism.languages.go;
Prism.languages.none = Prism.languages.go;
Prism.languages.console = Prism.languages.bash;
Prism.languages.shell = Prism.languages.bash;
Prism.languages.asm = Prism.languages.nasm;
Prism.languages.makefile = Prism.languages.bash;
Prism.languages.Dockerfile = Prism.languages.bash;
Prism.languages.protobuf = Prism.languages.clike;
Prism.languages.c = Prism.languages.clike;
</script>



	



	




	<script type="text/javascript" src="https://static.studygolang.com/static/dist/js/sidebar.min.js?v=0.2"></script>

	
		
		

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-4512014793067058",
    enable_page_level_ads: true
  });
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-18275235-2', 'auto');
  ga('send', 'pageview');

</script>


<script>
var _hmt = _hmt || [];
if (uid > 0) {
	_hmt.push(['_setUserTag', ''+uid, 1]);
}

(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?224c227cd9239761ec770bc8c1fb134c";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
<script>
(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  } else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script>

	

</body>
</html>
