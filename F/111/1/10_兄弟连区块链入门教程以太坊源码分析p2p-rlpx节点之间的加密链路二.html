<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<title>兄弟连区块链入门教程以太坊源码分析p2p-rlpx节点之间的加密链路二  - Go语言中文网 - Golang中文社区</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
	<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
	<meta charset="utf-8">
	<link rel="shortcut icon" href="https://static.studygolang.com/img/favicon.ico">
	<link rel="apple-touch-icon" type="image/png" href="https://static.studygolang.com/static/img/logo2.png">
	<meta name="keywords" content="Go,Golang,Go语言">
<meta name="description" content="兄弟连区块链入门教程以太坊源码分析p2p-rlpx节点之间的加密链路二 // Sign known message: static-shared-secret ^ nonce // 这个地方应该是直接使用了静态的共享秘密。 使用自己的私钥和对方的公钥生成的一个共享秘密。 token, err = h.staticSharedSecret(prv) if err != nil { return ni">
	<meta name="author" content="polaris <polaris@studygolang.com>">
	<link rel="canonical" href="https://studygolang.com/" />

	
	<link rel="stylesheet" href="https://static.studygolang.com/cssjs/fonts_googleapi.css">
	<link rel="stylesheet" href="https://static.studygolang.com/cssjs/cosmo_bootstrap.min.css">
	<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="https://static.studygolang.com/static/dist/css/sg_libs.min.css"/>
	<link rel="stylesheet" href="https://static.studygolang.com/static/dist/css/sg_styles.min.css?v=0.3"/>
	
	

<style>
pre .line { margin: auto; line-height: 20px; border-bottom: none; }
.image-package .image-container-fill { padding-bottom: 0 !important; }
</style>



<link href="https://cdn.staticfile.org/prism/9000.0.1/themes/prism-okaidia.min.css" rel="stylesheet">
<link href="https://cdn.staticfile.org/prism/9000.0.1/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">




	
	<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
	<script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
	
</head>
<body>
	<header class="navbar navbar-default navbar-fixed-top" role="navigation" style="position:relative;">
		<div class="container">
			
			<div class="navbar-header">
				<a href="/" class="navbar-brand" title="Go语言中文网"><img alt="Go语言中文网" src="https://static.studygolang.com/img/logo1.png" style="margin-top: -7px; height: 45px;"></a>
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
			</div>
			<div class="navbar-collapse collapse" id="navbar-main">
				<ul class="nav navbar-nav">
					<li class="">
						<a href="/topics">主题</a>
					</li>
					<li class="active">
						<a href="/articles">文章</a>
					</li>
					<li class="">
						<a href="/projects">项目</a>
					</li>
					<li class="">
						<a href="/resources">资源</a>
					</li>
					<li class="">
						<a href="/books">图书</a>
					</li>
					<li class="dropdown ">
						
						<a class="dropdown-toggle" data-toggle="dropdown" href="#" id="readings">晨读 <span class="caret"></span></a>
						<ul class="dropdown-menu" aria-labelledby="readings">
							<li><a href="/readings">Go晨读</a></li>
							<li><a href="/readings?rtype=1">综合晨读</a></li>
						</ul>
						
					</li>
					<li class="">
						<a href="/dl">下载<i class="newfuture"></i></a>
					</li>
					<li class="dropdown ">
						<a class="dropdown-toggle" data-toggle="dropdown" href="#" id="docs">官方文档 <span class="caret"></span></a>
						<ul class="dropdown-menu" aria-labelledby="docs">
						
							<li><a href="http://docs.studygolang.com" target="_blank">英文文档</a></li>
							<li><a href="http://docscn.studygolang.com" target="_blank">中文文档</a></li>
							<li><a href="/pkgdoc">标准库中文版</a></li>
							<li role="presentation" class="divider"></li>
							<li><a href="http://tour.studygolang.com" target="_blank">Go指南</a></li>
						
						</ul>
					</li>
				</ul>
				<form class="navbar-form navbar-left" action="/search" role="search" target="_blank">
					<input type="text" name="q" class="form-control search-query" placeholder="搜索" value="">
				</form>
				<ul class="nav navbar-nav navbar-right" id="userbar">
					
					<li class="first"><a href="/account/register">注册</a></li><li class="last"><a href="/account/login">登录</a></li>
					
				</ul>
			</div>
		</div>
	</header>
	<div class="wrapper" id="wrapper">
		<div class="container" role="main">
		

			
<div class="row">
	<div class="col-md-9 col-sm-6">
		<div class="sep20"></div>
		<ol class="breadcrumb">
			<li><a href="/">首页</a></li>
			<li><a href="/articles">文章</a></li>
		</ol>
		<div class="page">
			<div class="box_white">
				<div class="title">
					
					<h1 id="title" data-id="15783">
						兄弟连区块链入门教程以太坊源码分析p2p-rlpx节点之间的加密链路二
					</h1>
					<small class="c9">
					
						
						<span>兄弟连区块链培训</span>
						
					
						 · <span title="2018-10-25 17:34:42" class="timeago"></span> · 26 次点击 · 
						<span class="read-time"></span> · 
						<span class="timeago" title="2018-10-25 19:54:05"></span> 开始浏览 &nbsp; &nbsp;
					
					</small>
				</div>
				
				<div class="cell">
					
					<div id="myeditor" class="content article-entry">
						<p>兄弟连区块链入门教程以太坊源码分析p2p-rlpx节点之间的加密链路二</p>
<pre><code>     // Sign known message: static-shared-secret ^ nonce
    // 这个地方应该是直接使用了静态的共享秘密。 使用自己的私钥和对方的公钥生成的一个共享秘密。
    token, err = h.staticSharedSecret(prv)
    if err != nil {
        return nil, err
    }
    //这里我理解用共享秘密来加密这个initNonce。
    signed := xor(token, h.initNonce)
    // 使用随机的私钥来加密这个信息。
    signature, err := crypto.Sign(signed, h.randomPrivKey.ExportECDSA())
    if err != nil {
        return nil, err
    }

    msg := new(authMsgV4)
    copy(msg.Signature[:], signature)
    //这里把发起者的公钥告知对方。 这样对方使用自己的私钥和这个公钥可以生成静态的共享秘密。
    copy(msg.InitiatorPubkey[:], crypto.FromECDSAPub(&amp;prv.PublicKey)[1:])
    copy(msg.Nonce[:], h.initNonce)
    msg.Version = 4
    return msg, nil
}

// staticSharedSecret returns the static shared secret, the result
// of key agreement between the local and remote static node key.
func (h *encHandshake) staticSharedSecret(prv *ecdsa.PrivateKey) ([]byte, error) {
    return ecies.ImportECDSA(prv).GenerateShared(h.remotePub, sskLen, sskLen)
}
</code></pre>
<p>sealEIP8方法，这个方法是一个组包方法，对msg进行rlp的编码。 填充一些数据。 然后使用对方的公钥把数据进行加密。 这意味着只有对方的私钥才能解密这段信息。</p>
<pre><code>func sealEIP8(msg interface{}, h *encHandshake) ([]byte, error) {
    buf := new(bytes.Buffer)
    if err := rlp.Encode(buf, msg); err != nil {
        return nil, err
    }
    // pad with random amount of data. the amount needs to be at least 100 bytes to make
    // the message distinguishable from pre-EIP-8 handshakes.
    pad := padSpace[:mrand.Intn(len(padSpace)-100)+100]
    buf.Write(pad)
    prefix := make([]byte, 2)
    binary.BigEndian.PutUint16(prefix, uint16(buf.Len()+eciesOverhead))

    enc, err := ecies.Encrypt(rand.Reader, h.remotePub, buf.Bytes(), nil, prefix)
    return append(prefix, enc...), err
}</code></pre>
<p>readHandshakeMsg这个方法会从两个地方调用。 一个是在initiatorEncHandshake。一个就是在receiverEncHandshake。 这个方法比较简单。 首先用一种格式尝试解码。如果不行就换另外一种。应该是一种兼容性的设置。 基本上就是使用自己的私钥进行解码然后调用rlp解码成结构体。 结构体的描述就是下面的authRespV4,里面最重要的就是对端的随机公钥。 双方通过自己的私钥和对端的随机公钥可以得到一样的共享秘密。 而这个共享秘密是第三方拿不到的。</p>
<pre><code>// RLPx v4 handshake response (defined in EIP-8).
type authRespV4 struct {
    RandomPubkey [pubLen]byte
    Nonce [shaLen]byte
    Version uint

    // Ignore additional fields (forward-compatibility)
    Rest []rlp.RawValue `rlp:&#34;tail&#34;`
}


func readHandshakeMsg(msg plainDecoder, plainSize int, prv *ecdsa.PrivateKey, r io.Reader) ([]byte, error) {
    buf := make([]byte, plainSize)
    if _, err := io.ReadFull(r, buf); err != nil {
        return buf, err
    }
    // Attempt decoding pre-EIP-8 &#34;plain&#34; format.
    key := ecies.ImportECDSA(prv)
    if dec, err := key.Decrypt(rand.Reader, buf, nil, nil); err == nil {
        msg.decodePlain(dec)
        return buf, nil
    }
    // Could be EIP-8 format, try that.
    prefix := buf[:2]
    size := binary.BigEndian.Uint16(prefix)
    if size &lt; uint16(plainSize) {
        return buf, fmt.Errorf(&#34;size underflow, need at least %d bytes&#34;, plainSize)
    }
    buf = append(buf, make([]byte, size-uint16(plainSize)+2)...)
    if _, err := io.ReadFull(r, buf[plainSize:]); err != nil {
        return buf, err
    }
    dec, err := key.Decrypt(rand.Reader, buf[2:], nil, prefix)
    if err != nil {
        return buf, err
    }
    // Can&#39;t use rlp.DecodeBytes here because it rejects
    // trailing data (forward-compatibility).
    s := rlp.NewStream(bytes.NewReader(dec), 0)
    return buf, s.Decode(msg)
}</code></pre>
<p>handleAuthResp这个方法非常简单。</p>
<pre><code>func (h *encHandshake) handleAuthResp(msg *authRespV4) (err error) {
    h.respNonce = msg.Nonce[:]
    h.remoteRandomPub, err = importPublicKey(msg.RandomPubkey[:])
    return err
}</code></pre>
<p>最后是secrets函数，这个函数是在handshake完成之后调用。它通过自己的随机私钥和对端的公钥来生成一个共享秘密,这个共享秘密是瞬时的(只在当前这个链接中存在)。所以当有一天私钥被破解。 之前的消息还是安全的。</p>
<pre><code>// secrets is called after the handshake is completed.
// It extracts the connection secrets from the handshake values.
func (h *encHandshake) secrets(auth, authResp []byte) (secrets, error) {
    ecdheSecret, err := h.randomPrivKey.GenerateShared(h.remoteRandomPub, sskLen, sskLen)
    if err != nil {
        return secrets{}, err
    }

    // derive base secrets from ephemeral key agreement
    sharedSecret := crypto.Keccak256(ecdheSecret, crypto.Keccak256(h.respNonce, h.initNonce))
    aesSecret := crypto.Keccak256(ecdheSecret, sharedSecret)
    // 实际上这个MAC保护了ecdheSecret这个共享秘密。respNonce和initNonce这三个值
    s := secrets{
        RemoteID: h.remoteID,
        AES: aesSecret,
        MAC: crypto.Keccak256(ecdheSecret, aesSecret),
    }

    // setup sha3 instances for the MACs
    mac1 := sha3.NewKeccak256()
    mac1.Write(xor(s.MAC, h.respNonce))
    mac1.Write(auth)
    mac2 := sha3.NewKeccak256()
    mac2.Write(xor(s.MAC, h.initNonce))
    mac2.Write(authResp)
    //收到的每个包都会检查其MAC值是否满足计算的结果。如果不满足说明有问题。
    if h.initiator {
        s.EgressMAC, s.IngressMAC = mac1, mac2
    } else {
        s.EgressMAC, s.IngressMAC = mac2, mac1
    }

    return s, nil
}</code></pre>
<p>receiverEncHandshake函数和initiatorEncHandshake的内容大致相同。 但是顺序有些不一样。</p>
<pre><code>// receiverEncHandshake negotiates a session token on conn.
// it should be called on the listening side of the connection.
//
// prv is the local client&#39;s private key.
// token is the token from a previous session with this node.
func receiverEncHandshake(conn io.ReadWriter, prv *ecdsa.PrivateKey, token []byte) (s secrets, err error) {
    authMsg := new(authMsgV4)
    authPacket, err := readHandshakeMsg(authMsg, encAuthMsgLen, prv, conn)
    if err != nil {
        return s, err
    }
    h := new(encHandshake)
    if err := h.handleAuthMsg(authMsg, prv); err != nil {
        return s, err
    }

    authRespMsg, err := h.makeAuthResp()
    if err != nil {
        return s, err
    }
    var authRespPacket []byte
    if authMsg.gotPlain {
        authRespPacket, err = authRespMsg.sealPlain(h)
    } else {
        authRespPacket, err = sealEIP8(authRespMsg, h)
    }
    if err != nil {
        return s, err
    }
    if _, err = conn.Write(authRespPacket); err != nil {
        return s, err
    }
    return h.secrets(authPacket, authRespPacket)
}</code></pre>
<p>doProtocolHandshake<br/>这个方法比较简单， 加密信道已经创建完毕。 我们看到这里只是约定了是否使用Snappy加密然后就退出了。</p>
<pre><code>// doEncHandshake runs the protocol handshake using authenticated
// messages. the protocol handshake is the first authenticated message
// and also verifies whether the encryption handshake &#39;worked&#39; and the
// remote side actually provided the right public key.
func (t *rlpx) doProtoHandshake(our *protoHandshake) (their *protoHandshake, err error) {
    // Writing our handshake happens concurrently, we prefer
    // returning the handshake read error. If the remote side
    // disconnects us early with a valid reason, we should return it
    // as the error so it can be tracked elsewhere.
    werr := make(chan error, 1)
    go func() { werr &lt;- Send(t.rw, handshakeMsg, our) }()
    if their, err = readProtocolHandshake(t.rw, our); err != nil {
        &lt;-werr // make sure the write terminates too
        return nil, err
    }
    if err := &lt;-werr; err != nil {
        return nil, fmt.Errorf(&#34;write error: %v&#34;, err)
    }
    // If the protocol version supports Snappy encoding, upgrade immediately
    t.rw.snappy = their.Version &gt;= snappyProtocolVersion

    return their, nil
}</code></pre>
<p>rlpxFrameRW 数据分帧<br/>数据分帧主要通过rlpxFrameRW类来完成的。</p>
<pre><code>// rlpxFrameRW implements a simplified version of RLPx framing.
// chunked messages are not supported and all headers are equal to
// zeroHeader.
//
// rlpxFrameRW is not safe for concurrent use from multiple goroutines.
type rlpxFrameRW struct {
    conn io.ReadWriter
    enc cipher.Stream
    dec cipher.Stream

    macCipher cipher.Block
    egressMAC hash.Hash
    ingressMAC hash.Hash

    snappy bool
}
</code></pre>
<p>我们在完成两次握手之后。调用newRLPXFrameRW方法创建了这个对象。</p>
<pre><code>t.rw = newRLPXFrameRW(t.fd, sec)
</code></pre>
<p>然后提供ReadMsg和WriteMsg方法。这两个方法直接调用了rlpxFrameRW的ReadMsg和WriteMsg</p>
<pre><code>func (t *rlpx) ReadMsg() (Msg, error) {
    t.rmu.Lock()
    defer t.rmu.Unlock()
    t.fd.SetReadDeadline(time.Now().Add(frameReadTimeout))
    return t.rw.ReadMsg()
}
func (t *rlpx) WriteMsg(msg Msg) error {
    t.wmu.Lock()
    defer t.wmu.Unlock()
    t.fd.SetWriteDeadline(time.Now().Add(frameWriteTimeout))
    return t.rw.WriteMsg(msg)
}
</code></pre>
<p>WriteMsg</p>
<pre><code>func (rw *rlpxFrameRW) WriteMsg(msg Msg) error {
    ptype, _ := rlp.EncodeToBytes(msg.Code)

    // if snappy is enabled, compress message now
    if rw.snappy {
        if msg.Size &gt; maxUint24 {
            return errPlainMessageTooLarge
        }
        payload, _ := ioutil.ReadAll(msg.Payload)
        payload = snappy.Encode(nil, payload)

        msg.Payload = bytes.NewReader(payload)
        msg.Size = uint32(len(payload))
    }
    // write header
    headbuf := make([]byte, 32)
    fsize := uint32(len(ptype)) + msg.Size
    if fsize &gt; maxUint24 {
        return errors.New(&#34;message size overflows uint24&#34;)
    }
    putInt24(fsize, headbuf) // TODO: check overflow
    copy(headbuf[3:], zeroHeader)
    rw.enc.XORKeyStream(headbuf[:16], headbuf[:16]) // first half is now encrypted

    // write header MAC
    copy(headbuf[16:], updateMAC(rw.egressMAC, rw.macCipher, headbuf[:16]))
    if _, err := rw.conn.Write(headbuf); err != nil {
        return err
    }

    // write encrypted frame, updating the egress MAC hash with
    // the data written to conn.
    tee := cipher.StreamWriter{S: rw.enc, W: io.MultiWriter(rw.conn, rw.egressMAC)}
    if _, err := tee.Write(ptype); err != nil {
        return err
    }
    if _, err := io.Copy(tee, msg.Payload); err != nil {
        return err
    }
    if padding := fsize % 16; padding &gt; 0 {
        if _, err := tee.Write(zero16[:16-padding]); err != nil {
            return err
        }
    }

    // write frame MAC. egress MAC hash is up to date because
    // frame content was written to it as well.
    fmacseed := rw.egressMAC.Sum(nil)
    mac := updateMAC(rw.egressMAC, rw.macCipher, fmacseed)
    _, err := rw.conn.Write(mac)
    return err
}
</code></pre>
<p>ReadMsg</p>
<pre><code>func (rw *rlpxFrameRW) ReadMsg() (msg Msg, err error) {
    // read the header
    headbuf := make([]byte, 32)
    if _, err := io.ReadFull(rw.conn, headbuf); err != nil {
        return msg, err
    }
    // verify header mac
    shouldMAC := updateMAC(rw.ingressMAC, rw.macCipher, headbuf[:16])
    if !hmac.Equal(shouldMAC, headbuf[16:]) {
        return msg, errors.New(&#34;bad header MAC&#34;)
    }
    rw.dec.XORKeyStream(headbuf[:16], headbuf[:16]) // first half is now decrypted
    fsize := readInt24(headbuf)
    // ignore protocol type for now

    // read the frame content
    var rsize = fsize // frame size rounded up to 16 byte boundary
    if padding := fsize % 16; padding &gt; 0 {
        rsize += 16 - padding
    }
    framebuf := make([]byte, rsize)
    if _, err := io.ReadFull(rw.conn, framebuf); err != nil {
        return msg, err
    }

    // read and validate frame MAC. we can re-use headbuf for that.
    rw.ingressMAC.Write(framebuf)
    fmacseed := rw.ingressMAC.Sum(nil)
    if _, err := io.ReadFull(rw.conn, headbuf[:16]); err != nil {
        return msg, err
    }
    shouldMAC = updateMAC(rw.ingressMAC, rw.macCipher, fmacseed)
    if !hmac.Equal(shouldMAC, headbuf[:16]) {
        return msg, errors.New(&#34;bad frame MAC&#34;)
    }

    // decrypt frame content
    rw.dec.XORKeyStream(framebuf, framebuf)

    // decode message code
    content := bytes.NewReader(framebuf[:fsize])
    if err := rlp.Decode(content, &amp;msg.Code); err != nil {
        return msg, err
    }
    msg.Size = uint32(content.Len())
    msg.Payload = content

    // if snappy is enabled, verify and decompress message
    if rw.snappy {
        payload, err := ioutil.ReadAll(msg.Payload)
        if err != nil {
            return msg, err
        }
        size, err := snappy.DecodedLen(payload)
        if err != nil {
            return msg, err
        }
        if size &gt; int(maxUint24) {
            return msg, errPlainMessageTooLarge
        }
        payload, err = snappy.Decode(nil, payload)
        if err != nil {
            return msg, err
        }
        msg.Size, msg.Payload = uint32(size), bytes.NewReader(payload)
    }
    return msg, nil
}
</code></pre>
<p>帧结构</p>
<pre><code> normal = not chunked
 chunked-0 = First frame of a multi-frame packet
 chunked-n = Subsequent frames for multi-frame packet
 || is concatenate
 ^ is xor

Single-frame packet:
header || header-mac || frame || frame-mac

Multi-frame packet:
header || header-mac || frame-0 ||
[ header || header-mac || frame-n || ... || ]
header || header-mac || frame-last || frame-mac

header: frame-size || header-data || padding
frame-size: 3-byte integer size of frame, big endian encoded (excludes padding)
header-data:
 normal: rlp.list(protocol-type[, context-id])
 chunked-0: rlp.list(protocol-type, context-id, total-packet-size)
 chunked-n: rlp.list(protocol-type, context-id)
 values:
 protocol-type: &lt; 2**16
 context-id: &lt; 2**16 (optional for normal frames)
 total-packet-size: &lt; 2**32
padding: zero-fill to 16-byte boundary

header-mac: right128 of egress-mac.update(aes(mac-secret,egress-mac) ^ header-ciphertext).digest

frame:
 normal: rlp(packet-type) [|| rlp(packet-data)] || padding
 chunked-0: rlp(packet-type) || rlp(packet-data...)
 chunked-n: rlp(...packet-data) || padding
padding: zero-fill to 16-byte boundary (only necessary for last frame)

frame-mac: right128 of egress-mac.update(aes(mac-secret,egress-mac) ^ right128(egress-mac.update(frame-ciphertext).digest))

egress-mac: h256, continuously updated with egress-bytes*
ingress-mac: h256, continuously updated with ingress-bytes*
</code></pre>
<p>因为加密解密算法我也不是很熟，所以这里的分析还不是很彻底。 暂时只是分析了大致的流程。还有很多细节没有确认。</p>
					</div>
					

					
					<div class="row orig-info">
						<p>本文来自：<a href="/wr?u=http://segmentfault.com" target="_blank" title="Segmentfault">Segmentfault</a></p>
						<p>感谢作者：兄弟连区块链培训</p>
						<p>查看原文：<a href="/wr?u=https%3a%2f%2fsegmentfault.com%2fa%2f1190000016803474" target="_blank" title="兄弟连区块链入门教程以太坊源码分析p2p-rlpx节点之间的加密链路二">兄弟连区块链入门教程以太坊源码分析p2p-rlpx节点之间的加密链路二</a></p>
					</div>
					
				</div>
				
				<div class="content-buttons">
					<div class="pull-right c9 f11" style="line-height: 12px; padding-top: 3px; text-shadow: 0px 1px 0px #fff;">26 次点击 &nbsp;</div>
					<a class="tb collect" href="javascript:;" title="加入收藏" data-objid="15783" data-objtype="1" data-collect="">加入收藏</a> 
					<a href="javascript:" onclick="window.open('http://service.weibo.com/share/share.php?url=https://studygolang.com/articles/15783&title='+encodeURIComponent('Go语言中文网 - 兄弟连区块链入门教程以太坊源码分析p2p-rlpx节点之间的加密链路二 by 兄弟连区块链培训 #golang#'), '_blank', 'width=550,height=370');" class="tb">微博</a>
					<div id="content-thank">
						<a class="tb" href="javascript:;" title="赞" data-objid="15783" data-objtype="1" data-flag="">赞</a>
					</div>
				</div>
			</div>
			

			<div class="sep20"></div>
			<div class="box_white">
				<div class="cell subject">
					
					<div class="item-list">
					
						<a class="add-collection" href="javascript:"><i class="fa fa-plus"></i> 收入我的专栏</a>
					</div>
				</div>
			</div>

			<div class="sep20"></div>
			<div class="box_white">
				<div class="cell row">
					
					<div class="col-sm-6">上一篇：<a href="/articles/15782">兄弟连区块链入门教程以太坊源码分析p2p-rlpx节点之间的加密链路一</a></div>
					
					
					<div class="col-sm-6 right">下一篇：<a href="/articles/15784">兄弟连区块链入门教程以太坊源码分析fast sync算法一</a></div>
					
				</div>
			</div>

			<div class="sep20"></div>

			
			<div id="replies" class="box_white">
				<div class="cell">
					<div class="pull-right" style="margin: -3px -5px 0px 0px;">
					
						
						
						<a href="/tag/io" class="tag"><li class="fa fa-tag"></li> io</a>
						
						<a href="/tag/%e7%a7%81%e9%92%a5" class="tag"><li class="fa fa-tag"></li> 私钥</a>
						
						<a href="/tag/context" class="tag"><li class="fa fa-tag"></li> context</a>
						
						<a href="/tag/%e5%87%bd%e6%95%b0" class="tag"><li class="fa fa-tag"></li> 函数</a>
						
					
					</div>
					<span class="c9"><span class="cmtnum">0</span> 回复 </span>
				</div>
				<div class="comment-list cell" data-objid="15783" data-objtype="1" >
					<div class="words hide"><div class="text-center">暂无回复</div></div>
				</div>
			</div>

			
			
<div class="sep10"></div>
<div class="box_white page-comment">
	<input type="hidden" name="me-uid" value="0"/>
	<div class="cell">添加一条新回复
	
	<span class="h2-tip">
	（您需要 <a class="c-log" href="javascript:openPop('#login-pop');">登录</a> 后才能回复 <a href="/user/register" class="c-reg"> 没有账号</a> ？）</span>
	
	</div>
	<div class="cell">
		<div class="row clearfix md-toolbar">
			<ul class="col-md-10 list-inline comment-tab-menu" data-comment-group="default">
				<li class="comment-edit-tab cur"><a href="#" class="op">编辑</a></li>
				<li class="comment-preview-tab"><a href="#" class="op">预览</a></li>
				<li>
					<div class="nav reply-to dn" data-floor="" data-username="">
						<i class="fa fa-mail-reply" title=""></i>
						<a href="#reply" class="user" title=""></a>
						<a href="#" class="close"><i class="fa fa-close"></i></a>
					</div>
				</li>
			</ul>
			<div class="col-md-2 text-right">
				<i id="upload-img" class="glyphicon glyphicon-picture upload-img tool-tip" data-toggle="tooltip" data-placement="top" title="上传图片"></i>
			</div>
		</div>
		<div class="submit" id="commentForm">
			<div class="comment-content-text" data-comment-group="default">
				<textarea id="comment-content" name="content" class="comment-textarea main-textarea need-autogrow" rows="8"></textarea>
			</div>
			<div class="comment-content-preview cell" data-comment-group="default"></div>
			<div class="sub row">
				<ul class="help-block col-md-10">
					<li>请尽量让自己的回复能够对别人有帮助</li>
					<li class="markdown_tip">支持 Markdown 格式, <strong>**粗体**</strong>、~~删除线~~、<code>`单行代码`</code></li>
					<li>支持 @ 本站用户；支持表情（输入 : 提示），见 <a href="http://www.emoji-cheat-sheet.com/" target="_blank">Emoji cheat sheet</a></li>
					<li>图片支持拖拽、截图粘贴等方式上传</li>
				</ul>
				<div class="col-md-2 text-right"><button id="comment-submit" type="submit" title="提交" class="btn btn-default">提交</button></div>
			</div>
		</div>
	</div>
</div>

<style type="text/css">
#replies { margin-bottom: 15px; }
#replies .reply {
	margin: 0 -15px;
	padding: 15px 15px;
	position: relative;
	border-bottom: 1px solid #eee;
	padding-left: 74px;
}
#replies .reply .avatar {
	position: absolute;
	top: 15px;
	left: 15px;
}
.avatar-48 {
	width: 48px;
	height: 48px;
	border-radius: 120px;
}
.media-object {
	display: block;
}
.avatar-16 {
	width: 16px;
	height: 16px;
	border-radius: 120px;
}
#replies .reply .reply-to-block .info .media-object {
	display: inline-block;
	margin-right: 5px;
	vertical-align: top;
}
#replies .reply .reply-to-block .info {
	margin: 0;
}
#replies .reply .reply-to-block .info .user-name {
	font-weight: bold;
}
#replies .reply .reply-to-block {
	padding: 8px 15px;
	background: #f7f7f7;
	border-radius: 3px;
	margin-bottom: 10px;
}
.avatar .uface, .avatar .media-object {
	border-radius: 120px;
}
#replies .reply .infos {
	min-height: 48px;
}
#replies .reply .info {
	color: #999;
	margin-bottom: 6px;
	font-size: 12px;
}
#replies .reply .info .name {
	font-weight: bold;
	font-size: 13px;
}
#replies .reply .info .name a {
	color: #555;
}
#replies .reply .info .floor {
	color: #7AA87A;
}
#replies .reply .info a.time {
	color: #999;
	border-bottom: 1px dashed #ccc;
	text-decoration: none !important;
	cursor: pointer;
}
abbr[title] {
	border-bottom: 0px;
	cursor: pointer;
}
.opts {
	color: #666;
}
@media (min-width: 1026px) {
	#replies .reply .hideable {
		display: none;
	}
}
#replies .reply .opts a {
	display: inline-block;
	vertical-align: baseline;
	line-height: 22px;
	padding: 2px 5px;
	height: 22px;
	min-width: 22px;
	text-align: center;
}
#replies .info .opts a {
	font-size: 13px;
	margin-left: 5px;
	color: #999;
}
#replies .info .opts a.edit {
	display: none;
}
.markdown {
	position: relative;
	letter-spacing: .03em;
	font-size: 15px;
	text-overflow: ellipsis;
	word-wrap: break-word;
}
.markdown img.twemoji {
	width: 20px;
}
.markdown img {
	vertical-align: top;
	max-width: 100%;
}
.markdown p {
	font-size: 14px;
	line-height: 26px;
	margin-bottom: 0;
	color: #000;
}
.md-toolbar .reply-to {
    padding-top: 3px;
    padding-left: 8px;
}
.close {
    float: right;
    font-size: 21px;
    font-weight: 700;
    line-height: 1;
    color: #000;
    text-shadow: 0 1px 0 #fff;
    filter: alpha(opacity=20);
    opacity: .2;
}
a.close:hover {
	background-color: #d0d0d0;
    color: #666
}
.md-toolbar .reply-to .close {
    font-size: 14px;
    margin-left: 5px;
    margin-top: 1px;
}
.edit-wrapper {
	display: none;
	border: 1px solid #c0d3eb;
	padding: 8px;
	border-radius: 4px;
}

.edit-textarea {
	resize: none;
	width: 100%;
	color: #000;
	font-size: 14px;
	border: 1px solid #E5E5E5;
	padding: 5px;
}
.btn-edit {
	cursor: pointer;
}


</style>

<script type="text/x-jsrender" id="one-comment">
<div class="reply [%if is_new%]light[%/if%]" id="reply-[%:comment.floor%]">
	<div data-floor="[%:comment.floor%]">
		<div class="avatar"><a title="[%:user.username%]" href="/user/[%:user.username%]"><img class="media-object avatar-48" src="[%:user.avatar%]" alt="[%:user.username%]"></a></div>
			<div class="infos">
				<div class="info">
					<span class="name">
						<a class="user-name" data-name="[%:user.name%]" href="/user/[%:user.username%]">[%:user.username%]</a>
					</span> ·
					<span class="floor">#[%:comment.floor%]</span> ·
					<abbr class="timeago" title="[%:comment.ctime%]">[%:comment.cmt_time%]</abbr>
					<span class="opts pull-right">
						<span class="op-reply hideable">
							[%if me.uid == user.uid %]
								<a data-floor="[%:comment.floor%]" title="编辑" class="btn-edit glyphicon glyphicon-edit"></a>
							[%/if%]
						  <a data-floor="[%:comment.floor%]" data-username="[%:user.username%]" title="回复此楼" class="btn-reply fa fa-mail-reply" href="#"></a>
						</span>
						
					</span>
				</div>
				[%if comment.reply_floor > 0%]
				<div class="reply-to-block">
					<div class="info reply_user">
						对
						<a data-remote="true" href="/user/[%:comment.reply_user.username%]">
							<img class="media-object avatar-16" src="[%:comment.reply_user.avatar%]" alt="[%:comment.reply_user.username%]"><span class="user-name">[%:comment.reply_user.username%]</span>
						</a>
						<a href="#reply-[%:comment.reply_floor%]"><span class="reply-floor">#[%:comment.reply_floor%]</span></a> 回复
					</div>
					<div class="markdown dn">
						<p>[%:comment.reply_content%]</p>
					</div>
				</div>
				[%/if%]

			<div class="markdown" data-floor="[%:comment.floor%]">
				<div class="content">[%:comment.content%]</div>
				<div class="edit-wrapper">
					<div class="row clearfix md-toolbar">
						<ul class="col-md-10 list-inline comment-tab-menu" data-comment-group="[%:comment.floor%]">
								<li class="comment-edit-tab cur"><a href="#" class="op">编辑</a></li>
								<li class="comment-preview-tab"><a href="#" class="op">预览</a></li>
						</ul>
						<div class="col-md-2 text-right">
							<i data-floor="[%:comment.floor%]" class="glyphicon glyphicon-picture upload-img tool-tip" data-toggle="tooltip" data-placement="top" title="上传图片"></i>
						</div>
					</div>
					<div class="comment-content-text" data-comment-group="[%:comment.floor%]">
						<textarea data-raw-content="[%:comment.rawContent%]" name="content" class="comment-textarea" rows="8" style="width: 100%;">[%:comment.rawContent%]</textarea>
					</div>
					<div class="comment-content-preview cell" data-comment-group="[%:comment.floor%]"></div>
					<div class="text-right">
						<button type="submit" title="提交" data-cid="[%:comment.cid%]" data-floor="[%:comment.floor%]" class="submit btn btn-default">提交</button>
						<button title="取消" data-floor="[%:comment.floor%]" class="cancel btn btn-default">取消</button>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>
</script>


			

			
		</div>
	</div>
	<div class="col-md-3 col-sm-6">
		<div class="sep20"></div>
		<div class="box_white sidebar">
	
	<div class="top">
		<h3 class="title"><i class="glyphicon glyphicon-user"></i> 用户登录</h3>
	</div>
	<div class="sb-content inner_content" style="padding-bottom: 0;">
		<form action="/account/login" method="post" class="form-horizontal login" role="form" style="padding-top: 0; padding-bottom: 0;">
			<div class="form-group">
				<div class="col-sm-10">
					<input type="text" class="form-control input-sm" id="username" name="username" placeholder="请填写用户名或邮箱">
				</div>
			</div>
			<div class="form-group">
				<div class="col-sm-10">
					<input type="password" class="form-control input-sm" id="passwd" name="passwd" placeholder="请填写密码">
				</div>
			</div>
			<div class="form-group">
				<div class="col-sm-10">
					<div class="checkbox">
						<label>
							<input id="user_remember_me" name="remember_me" type="checkbox" value="1" checked="checked" />	记住登录状态
						</label>
						<input class="btn btn-default btn-sm" data-disable-with="正在登录" name="commit" type="submit" value="登录" />
					</div>
					<div class="sep10"></div>
					<a href="/oauth/github/login" class="btn btn-default btn-sm">
						<i class="fa fa-github" aria-hidden="true"></i>
						GitHub 登录
					</a>
				</div>
			</div>
		</form>
	</div>
	
</div>





		
		<div class="box_white sidebar" id="ad-right1">
			
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-4512014793067058"
     data-ad-slot="4230018468"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
			
		</div>
		

		<div class="box_white sidebar">
	<div class="top">
		<h3 class="title"><i class="glyphicon glyphicon-stats"></i>&nbsp;今日阅读排行</h3>
	</div>
	<div class="sb-content">
		<div class="rank-list" data-objtype="1" data-limit="10" data-rank_type="today">
			<ul class="list-unstyled">
				<img src="/static/img/loaders/loader7.gif" alt="加载中" />
			</ul>
		</div>
	</div>
</div>
		
		
		<div class="box_white sidebar" id="ad-right2">
			
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 侧边栏自适应 -->
<ins class="adsbygoogle"
     style="display:inline-block;min-width:270px;max-width:970px;width:100%;height:290px"
     data-ad-client="ca-pub-4512014793067058"
     data-ad-slot="3487838313"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			
		</div>
		

		<div class="box_white sidebar">
	<div class="top">
		<h3 class="title"><i class="glyphicon glyphicon-stats"></i>&nbsp;一周阅读排行</h3>
	</div>
	<div class="sb-content">
		<div class="rank-list" data-objtype="1" data-limit="10" data-rank_type="week">
			<ul class="list-unstyled">
				<img src="/static/img/loaders/loader7.gif" alt="加载中" />
			</ul>
		</div>
	</div>
</div>
		
	</div>
</div>

<link rel="stylesheet" href="https://static.studygolang.com/static/dist/css/modal.min.css?v=0.1">
<div class="modal contribute-modal animated" style="display: none;">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close">×</button>
                <h4 class="modal-title">
                    给该专栏投稿
                    <a href="/articles/new" class="new-note-btn">写篇新文章</a>
                </h4>
                <span class="notice">每篇文章有总共有 5 次投稿机会</span>
                <div>
                    <input type="text" placeholder="搜索我的文章" class="search-input">
                    <a class="search-btn">
                        <i class="fa fa-search" aria-hidden="true" style="margin: 8px -1px 0 0;display: block;"></i>
                    </a>
                </div>
            </div>
            <div class="modal-body">
                <ul id="contribute-note-list"></ul>
                <div class="modal-notes-placeholder" style="display: none;">
                    <div class="text"></div>
                    <div class="btn"></div>
                </div>
            </div>
            <div class="modal-footer"></div>
        </div>
    </div>
</div>


<div class="modal animated add-self" style="display: none;">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" data-dismiss="modal" class="close">×</button>
                <h4 class="modal-title">收入到我管理的专栏
                    <span class="new-collection-btn"><a href="/subject/new" target="_blank">新建专栏</a></span>
                </h4>
            </div>
            <div class="modal-body">
                <div class="search">
                    <input type="search" name="search-self" placeholder="搜索我管理的专栏">
                    <a class="search-btn">
                        <i class="fa fa-search" aria-hidden="true" style="margin: 6px 1px 0 0;display: block;"></i>
                    </a>
                </div>
                <ul id="self-note-list"></ul>
                <div class="modal-collections-placeholder" style="display: none;">
                    <div class="avatar"></div>
                    <div class="wrap">
                        <div class="btn"></div>
                        <div class="name"></div>
                        <div class="text"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer"></div>
        </div>
    </div>
</div>



<template id="content_tpl">
<p>兄弟连区块链入门教程以太坊源码分析p2p-rlpx节点之间的加密链路二</p>
<pre><code>     // Sign known message: static-shared-secret ^ nonce
    // 这个地方应该是直接使用了静态的共享秘密。 使用自己的私钥和对方的公钥生成的一个共享秘密。
    token, err = h.staticSharedSecret(prv)
    if err != nil {
        return nil, err
    }
    //这里我理解用共享秘密来加密这个initNonce。
    signed := xor(token, h.initNonce)
    // 使用随机的私钥来加密这个信息。
    signature, err := crypto.Sign(signed, h.randomPrivKey.ExportECDSA())
    if err != nil {
        return nil, err
    }

    msg := new(authMsgV4)
    copy(msg.Signature[:], signature)
    //这里把发起者的公钥告知对方。 这样对方使用自己的私钥和这个公钥可以生成静态的共享秘密。
    copy(msg.InitiatorPubkey[:], crypto.FromECDSAPub(&amp;prv.PublicKey)[1:])
    copy(msg.Nonce[:], h.initNonce)
    msg.Version = 4
    return msg, nil
}

// staticSharedSecret returns the static shared secret, the result
// of key agreement between the local and remote static node key.
func (h *encHandshake) staticSharedSecret(prv *ecdsa.PrivateKey) ([]byte, error) {
    return ecies.ImportECDSA(prv).GenerateShared(h.remotePub, sskLen, sskLen)
}
</code></pre>
<p>sealEIP8方法，这个方法是一个组包方法，对msg进行rlp的编码。 填充一些数据。 然后使用对方的公钥把数据进行加密。 这意味着只有对方的私钥才能解密这段信息。</p>
<pre><code>func sealEIP8(msg interface{}, h *encHandshake) ([]byte, error) {
    buf := new(bytes.Buffer)
    if err := rlp.Encode(buf, msg); err != nil {
        return nil, err
    }
    // pad with random amount of data. the amount needs to be at least 100 bytes to make
    // the message distinguishable from pre-EIP-8 handshakes.
    pad := padSpace[:mrand.Intn(len(padSpace)-100)+100]
    buf.Write(pad)
    prefix := make([]byte, 2)
    binary.BigEndian.PutUint16(prefix, uint16(buf.Len()+eciesOverhead))

    enc, err := ecies.Encrypt(rand.Reader, h.remotePub, buf.Bytes(), nil, prefix)
    return append(prefix, enc...), err
}</code></pre>
<p>readHandshakeMsg这个方法会从两个地方调用。 一个是在initiatorEncHandshake。一个就是在receiverEncHandshake。 这个方法比较简单。 首先用一种格式尝试解码。如果不行就换另外一种。应该是一种兼容性的设置。 基本上就是使用自己的私钥进行解码然后调用rlp解码成结构体。 结构体的描述就是下面的authRespV4,里面最重要的就是对端的随机公钥。 双方通过自己的私钥和对端的随机公钥可以得到一样的共享秘密。 而这个共享秘密是第三方拿不到的。</p>
<pre><code>// RLPx v4 handshake response (defined in EIP-8).
type authRespV4 struct {
    RandomPubkey [pubLen]byte
    Nonce [shaLen]byte
    Version uint

    // Ignore additional fields (forward-compatibility)
    Rest []rlp.RawValue `rlp:&#34;tail&#34;`
}


func readHandshakeMsg(msg plainDecoder, plainSize int, prv *ecdsa.PrivateKey, r io.Reader) ([]byte, error) {
    buf := make([]byte, plainSize)
    if _, err := io.ReadFull(r, buf); err != nil {
        return buf, err
    }
    // Attempt decoding pre-EIP-8 &#34;plain&#34; format.
    key := ecies.ImportECDSA(prv)
    if dec, err := key.Decrypt(rand.Reader, buf, nil, nil); err == nil {
        msg.decodePlain(dec)
        return buf, nil
    }
    // Could be EIP-8 format, try that.
    prefix := buf[:2]
    size := binary.BigEndian.Uint16(prefix)
    if size &lt; uint16(plainSize) {
        return buf, fmt.Errorf(&#34;size underflow, need at least %d bytes&#34;, plainSize)
    }
    buf = append(buf, make([]byte, size-uint16(plainSize)+2)...)
    if _, err := io.ReadFull(r, buf[plainSize:]); err != nil {
        return buf, err
    }
    dec, err := key.Decrypt(rand.Reader, buf[2:], nil, prefix)
    if err != nil {
        return buf, err
    }
    // Can&#39;t use rlp.DecodeBytes here because it rejects
    // trailing data (forward-compatibility).
    s := rlp.NewStream(bytes.NewReader(dec), 0)
    return buf, s.Decode(msg)
}</code></pre>
<p>handleAuthResp这个方法非常简单。</p>
<pre><code>func (h *encHandshake) handleAuthResp(msg *authRespV4) (err error) {
    h.respNonce = msg.Nonce[:]
    h.remoteRandomPub, err = importPublicKey(msg.RandomPubkey[:])
    return err
}</code></pre>
<p>最后是secrets函数，这个函数是在handshake完成之后调用。它通过自己的随机私钥和对端的公钥来生成一个共享秘密,这个共享秘密是瞬时的(只在当前这个链接中存在)。所以当有一天私钥被破解。 之前的消息还是安全的。</p>
<pre><code>// secrets is called after the handshake is completed.
// It extracts the connection secrets from the handshake values.
func (h *encHandshake) secrets(auth, authResp []byte) (secrets, error) {
    ecdheSecret, err := h.randomPrivKey.GenerateShared(h.remoteRandomPub, sskLen, sskLen)
    if err != nil {
        return secrets{}, err
    }

    // derive base secrets from ephemeral key agreement
    sharedSecret := crypto.Keccak256(ecdheSecret, crypto.Keccak256(h.respNonce, h.initNonce))
    aesSecret := crypto.Keccak256(ecdheSecret, sharedSecret)
    // 实际上这个MAC保护了ecdheSecret这个共享秘密。respNonce和initNonce这三个值
    s := secrets{
        RemoteID: h.remoteID,
        AES: aesSecret,
        MAC: crypto.Keccak256(ecdheSecret, aesSecret),
    }

    // setup sha3 instances for the MACs
    mac1 := sha3.NewKeccak256()
    mac1.Write(xor(s.MAC, h.respNonce))
    mac1.Write(auth)
    mac2 := sha3.NewKeccak256()
    mac2.Write(xor(s.MAC, h.initNonce))
    mac2.Write(authResp)
    //收到的每个包都会检查其MAC值是否满足计算的结果。如果不满足说明有问题。
    if h.initiator {
        s.EgressMAC, s.IngressMAC = mac1, mac2
    } else {
        s.EgressMAC, s.IngressMAC = mac2, mac1
    }

    return s, nil
}</code></pre>
<p>receiverEncHandshake函数和initiatorEncHandshake的内容大致相同。 但是顺序有些不一样。</p>
<pre><code>// receiverEncHandshake negotiates a session token on conn.
// it should be called on the listening side of the connection.
//
// prv is the local client&#39;s private key.
// token is the token from a previous session with this node.
func receiverEncHandshake(conn io.ReadWriter, prv *ecdsa.PrivateKey, token []byte) (s secrets, err error) {
    authMsg := new(authMsgV4)
    authPacket, err := readHandshakeMsg(authMsg, encAuthMsgLen, prv, conn)
    if err != nil {
        return s, err
    }
    h := new(encHandshake)
    if err := h.handleAuthMsg(authMsg, prv); err != nil {
        return s, err
    }

    authRespMsg, err := h.makeAuthResp()
    if err != nil {
        return s, err
    }
    var authRespPacket []byte
    if authMsg.gotPlain {
        authRespPacket, err = authRespMsg.sealPlain(h)
    } else {
        authRespPacket, err = sealEIP8(authRespMsg, h)
    }
    if err != nil {
        return s, err
    }
    if _, err = conn.Write(authRespPacket); err != nil {
        return s, err
    }
    return h.secrets(authPacket, authRespPacket)
}</code></pre>
<p>doProtocolHandshake<br/>这个方法比较简单， 加密信道已经创建完毕。 我们看到这里只是约定了是否使用Snappy加密然后就退出了。</p>
<pre><code>// doEncHandshake runs the protocol handshake using authenticated
// messages. the protocol handshake is the first authenticated message
// and also verifies whether the encryption handshake &#39;worked&#39; and the
// remote side actually provided the right public key.
func (t *rlpx) doProtoHandshake(our *protoHandshake) (their *protoHandshake, err error) {
    // Writing our handshake happens concurrently, we prefer
    // returning the handshake read error. If the remote side
    // disconnects us early with a valid reason, we should return it
    // as the error so it can be tracked elsewhere.
    werr := make(chan error, 1)
    go func() { werr &lt;- Send(t.rw, handshakeMsg, our) }()
    if their, err = readProtocolHandshake(t.rw, our); err != nil {
        &lt;-werr // make sure the write terminates too
        return nil, err
    }
    if err := &lt;-werr; err != nil {
        return nil, fmt.Errorf(&#34;write error: %v&#34;, err)
    }
    // If the protocol version supports Snappy encoding, upgrade immediately
    t.rw.snappy = their.Version &gt;= snappyProtocolVersion

    return their, nil
}</code></pre>
<p>rlpxFrameRW 数据分帧<br/>数据分帧主要通过rlpxFrameRW类来完成的。</p>
<pre><code>// rlpxFrameRW implements a simplified version of RLPx framing.
// chunked messages are not supported and all headers are equal to
// zeroHeader.
//
// rlpxFrameRW is not safe for concurrent use from multiple goroutines.
type rlpxFrameRW struct {
    conn io.ReadWriter
    enc cipher.Stream
    dec cipher.Stream

    macCipher cipher.Block
    egressMAC hash.Hash
    ingressMAC hash.Hash

    snappy bool
}
</code></pre>
<p>我们在完成两次握手之后。调用newRLPXFrameRW方法创建了这个对象。</p>
<pre><code>t.rw = newRLPXFrameRW(t.fd, sec)
</code></pre>
<p>然后提供ReadMsg和WriteMsg方法。这两个方法直接调用了rlpxFrameRW的ReadMsg和WriteMsg</p>
<pre><code>func (t *rlpx) ReadMsg() (Msg, error) {
    t.rmu.Lock()
    defer t.rmu.Unlock()
    t.fd.SetReadDeadline(time.Now().Add(frameReadTimeout))
    return t.rw.ReadMsg()
}
func (t *rlpx) WriteMsg(msg Msg) error {
    t.wmu.Lock()
    defer t.wmu.Unlock()
    t.fd.SetWriteDeadline(time.Now().Add(frameWriteTimeout))
    return t.rw.WriteMsg(msg)
}
</code></pre>
<p>WriteMsg</p>
<pre><code>func (rw *rlpxFrameRW) WriteMsg(msg Msg) error {
    ptype, _ := rlp.EncodeToBytes(msg.Code)

    // if snappy is enabled, compress message now
    if rw.snappy {
        if msg.Size &gt; maxUint24 {
            return errPlainMessageTooLarge
        }
        payload, _ := ioutil.ReadAll(msg.Payload)
        payload = snappy.Encode(nil, payload)

        msg.Payload = bytes.NewReader(payload)
        msg.Size = uint32(len(payload))
    }
    // write header
    headbuf := make([]byte, 32)
    fsize := uint32(len(ptype)) + msg.Size
    if fsize &gt; maxUint24 {
        return errors.New(&#34;message size overflows uint24&#34;)
    }
    putInt24(fsize, headbuf) // TODO: check overflow
    copy(headbuf[3:], zeroHeader)
    rw.enc.XORKeyStream(headbuf[:16], headbuf[:16]) // first half is now encrypted

    // write header MAC
    copy(headbuf[16:], updateMAC(rw.egressMAC, rw.macCipher, headbuf[:16]))
    if _, err := rw.conn.Write(headbuf); err != nil {
        return err
    }

    // write encrypted frame, updating the egress MAC hash with
    // the data written to conn.
    tee := cipher.StreamWriter{S: rw.enc, W: io.MultiWriter(rw.conn, rw.egressMAC)}
    if _, err := tee.Write(ptype); err != nil {
        return err
    }
    if _, err := io.Copy(tee, msg.Payload); err != nil {
        return err
    }
    if padding := fsize % 16; padding &gt; 0 {
        if _, err := tee.Write(zero16[:16-padding]); err != nil {
            return err
        }
    }

    // write frame MAC. egress MAC hash is up to date because
    // frame content was written to it as well.
    fmacseed := rw.egressMAC.Sum(nil)
    mac := updateMAC(rw.egressMAC, rw.macCipher, fmacseed)
    _, err := rw.conn.Write(mac)
    return err
}
</code></pre>
<p>ReadMsg</p>
<pre><code>func (rw *rlpxFrameRW) ReadMsg() (msg Msg, err error) {
    // read the header
    headbuf := make([]byte, 32)
    if _, err := io.ReadFull(rw.conn, headbuf); err != nil {
        return msg, err
    }
    // verify header mac
    shouldMAC := updateMAC(rw.ingressMAC, rw.macCipher, headbuf[:16])
    if !hmac.Equal(shouldMAC, headbuf[16:]) {
        return msg, errors.New(&#34;bad header MAC&#34;)
    }
    rw.dec.XORKeyStream(headbuf[:16], headbuf[:16]) // first half is now decrypted
    fsize := readInt24(headbuf)
    // ignore protocol type for now

    // read the frame content
    var rsize = fsize // frame size rounded up to 16 byte boundary
    if padding := fsize % 16; padding &gt; 0 {
        rsize += 16 - padding
    }
    framebuf := make([]byte, rsize)
    if _, err := io.ReadFull(rw.conn, framebuf); err != nil {
        return msg, err
    }

    // read and validate frame MAC. we can re-use headbuf for that.
    rw.ingressMAC.Write(framebuf)
    fmacseed := rw.ingressMAC.Sum(nil)
    if _, err := io.ReadFull(rw.conn, headbuf[:16]); err != nil {
        return msg, err
    }
    shouldMAC = updateMAC(rw.ingressMAC, rw.macCipher, fmacseed)
    if !hmac.Equal(shouldMAC, headbuf[:16]) {
        return msg, errors.New(&#34;bad frame MAC&#34;)
    }

    // decrypt frame content
    rw.dec.XORKeyStream(framebuf, framebuf)

    // decode message code
    content := bytes.NewReader(framebuf[:fsize])
    if err := rlp.Decode(content, &amp;msg.Code); err != nil {
        return msg, err
    }
    msg.Size = uint32(content.Len())
    msg.Payload = content

    // if snappy is enabled, verify and decompress message
    if rw.snappy {
        payload, err := ioutil.ReadAll(msg.Payload)
        if err != nil {
            return msg, err
        }
        size, err := snappy.DecodedLen(payload)
        if err != nil {
            return msg, err
        }
        if size &gt; int(maxUint24) {
            return msg, errPlainMessageTooLarge
        }
        payload, err = snappy.Decode(nil, payload)
        if err != nil {
            return msg, err
        }
        msg.Size, msg.Payload = uint32(size), bytes.NewReader(payload)
    }
    return msg, nil
}
</code></pre>
<p>帧结构</p>
<pre><code> normal = not chunked
 chunked-0 = First frame of a multi-frame packet
 chunked-n = Subsequent frames for multi-frame packet
 || is concatenate
 ^ is xor

Single-frame packet:
header || header-mac || frame || frame-mac

Multi-frame packet:
header || header-mac || frame-0 ||
[ header || header-mac || frame-n || ... || ]
header || header-mac || frame-last || frame-mac

header: frame-size || header-data || padding
frame-size: 3-byte integer size of frame, big endian encoded (excludes padding)
header-data:
 normal: rlp.list(protocol-type[, context-id])
 chunked-0: rlp.list(protocol-type, context-id, total-packet-size)
 chunked-n: rlp.list(protocol-type, context-id)
 values:
 protocol-type: &lt; 2**16
 context-id: &lt; 2**16 (optional for normal frames)
 total-packet-size: &lt; 2**32
padding: zero-fill to 16-byte boundary

header-mac: right128 of egress-mac.update(aes(mac-secret,egress-mac) ^ header-ciphertext).digest

frame:
 normal: rlp(packet-type) [|| rlp(packet-data)] || padding
 chunked-0: rlp(packet-type) || rlp(packet-data...)
 chunked-n: rlp(...packet-data) || padding
padding: zero-fill to 16-byte boundary (only necessary for last frame)

frame-mac: right128 of egress-mac.update(aes(mac-secret,egress-mac) ^ right128(egress-mac.update(frame-ciphertext).digest))

egress-mac: h256, continuously updated with egress-bytes*
ingress-mac: h256, continuously updated with ingress-bytes*
</code></pre>
<p>因为加密解密算法我也不是很熟，所以这里的分析还不是很彻底。 暂时只是分析了大致的流程。还有很多细节没有确认。</p>
</template>



		</div>
	</div>
	<div class="sep10"></div>
	<footer id="bottom">
		<div class="container nav-content">
			<div class="inner_content">
				<div class="sep10"></div>   
				<strong>
					
					<a href="/wiki/about" class="dark">关于</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/faq" class="dark">FAQ</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/contributors" class="dark">贡献者</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/go/feedback" class="dark">反馈</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://github.com/studygolang" class="dark">Github</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="http://weibo.com/studygolang" class="dark">新浪微博</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="https://play.studygolang.com" class="dark">Play</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/duty" class="dark">免责声明</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/contact" class="dark">联系我们</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/donate" class="dark">捐赠</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/wiki/cool" class="dark">酷站</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<a href="/feed.html" class="dark">Feed订阅</a> &nbsp; <span class="snow">•</span> &nbsp; 
					
					<span id="onlineusers">1502</span> 人在线
				</strong>
				&nbsp;<span class="cc">最高记录 <span id="maxonline">2928</span></span>
				<div class="sep20"></div>
				&copy;2013-2018 studygolang.com Go语言中文网，中国 Golang 社区，致力于构建完善的 Golang 中文社区，Go语言爱好者的学习家园。
				<div class="sep5"></div>
				Powered by <a href="https://github.com/studygolang/studygolang">StudyGolang(Golang + MySQL)</a> &nbsp;<span class="snow">•</span>&nbsp;<span class="snow">·</span>&nbsp;CDN 采用 <a href="https://portal.qiniu.com/signup?code=3lfz4at7pxfma" title="七牛云" class="dark" target="_blank">七牛云</a>
				<div class="sep20"></div>
				<span class="small cc">VERSION: V3.5.0&nbsp;<span class="snow">·</span>&nbsp;154.011747ms&nbsp;<span class="snow">·</span>&nbsp;<strong>为了更好的体验，本站推荐使用 Chrome 或 Firefox 浏览器</strong></span>
				<div class="sep20"></div>
				<span class="f12 c9"><a href="http://www.miibeian.gov.cn/" target="_blank" rel="nofollow">京ICP备14030343号-1</a></span>
				<div class="sep10"></div>
			</div>
		</div>
	</footer>

	<div id="gotop"></div>

	
	<input type="hidden" id="is_login_status" value="0" />
	<div class="pop login-pop" id="login-pop">
		<div style="position: relative;"><span class="close" style="position: absolute; right: -15px; top: -15px; cursor: pointer; color: #000; font-size: 13px;">X</span></div>
		<div class="login-form">
			<div class="error text-center"></div>
			<div class="text-center" style="margin-bottom: 5px;">登录和大家一起探讨吧</div>
			<form action="#" method="post" class="form-horizontal" role="form">
				<div class="form-group">
					<label for="username" class="col-sm-3 control-label">用户名</label>
					<div class="col-sm-9 form-input">
						<input type="text" class="form-control" id="form_username" name="username" placeholder="请填写用户名或邮箱">
					</div>
				</div>
				<div class="form-group">
					<label for="passwd" class="col-sm-3 control-label">密码</label>
					<div class="col-sm-9 form-input">
						<input type="password" class="form-control" id="form_passwd" name="passwd" placeholder="密码">
					</div>
				</div>
				<div class="form-group">
					<div class="col-sm-offset-2 col-sm-10">
						<div class="checkbox">
							<label>
								<input id="user_remember_me" name="remember_me" type="checkbox" value="1" checked="checked" />	记住登录状态
							</label>
							<button type="submit" id="login-btn" class="btn btn-default btn-sm">登录</button>
						</div>
					</div>
				</div>
				<div class="form-group">
					<div class="col-sm-offset-2 col-sm-10">
						<a id="login-github" href="/oauth/github/login" class="btn btn-default btn-sm pull-left">
							<i class="fa fa-github" aria-hidden="true"></i>
							GitHub 登录
						</a>
						<div class="forget">
							<a href="/account/forgetpwd" title="点击找回密码">忘记密码？</a>
						</div>
						<div class="register">
							<span>还不是会员</span><a href="/account/register">现在注册</a>
						</div>
					</div>
				</div>
			</form>
		</div>
	</div>
	<div id="sg-overlay"></div>
	
	
	<script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
	<script src="https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
	<script src="https://cdn.staticfile.org/jquery-timeago/1.6.1/jquery.timeago.min.js"></script>
	<script src="https://cdn.staticfile.org/zoom.js/0.0.1/zoom.min.js"></script>
	<script src="https://cdn.staticfile.org/marked/0.3.6/marked.min.js"></script>
	<script src="https://cdn.staticfile.org/Caret.js/0.3.1/jquery.caret.min.js"></script>
	<script src="https://cdn.staticfile.org/emojify.js/1.1.0/js/emojify.min.js"></script>

	<script type="text/javascript">
	var uid =  0 ;
	var isHttps =  true ,
		cdnDomain = "https:\/\/static.studygolang.com\/";
	if (isHttps) {
		var wsUrl = 'wss://studygolang.com/ws?uid='+uid;
	} else {
		var wsUrl = 'ws://studygolang.com/ws?uid='+uid;
	}
	var GLaunchTime =  1540036286 *1000;
	</script>
	<script src="https://cdn.staticfile.org/lscache/1.1.0/lscache.min.js"></script>
	<script src="https://cdn.staticfile.org/jsrender/0.9.90/jsrender.min.js"></script>
	<script src="https://cdn.staticfile.org/plupload/3.1.1/plupload.full.min.js"></script>
	<script type="text/javascript">
	$.views.settings.delimiters("[%", "%]");
	
	</script>

	<script src="https://static.studygolang.com/static/dist/js/sg_libs.min.js"></script>
	<script src="https://static.studygolang.com/static/dist/js/sg_base.min.js?v=0.4"></script>

	

<script type="text/javascript" src="https://static.studygolang.com/static/dist/js/articles.min.js"></script>

<script type="text/javascript">

SG.SIDE_BARS = [
	"/rank/view",
];

var keyprefix = 'article';
var objid =  15783 ;

$(function(){
	
	
	
	$('.need-autogrow').autoGrow();
	
	loadComments();

	
	$('#wrapper .content').on('mousedown', 'a', function(evt){
		var url = $(this).attr('href');
		
		$(this).attr('href', url);
		$(this).attr('target', '_blank');
	});

	var len = '兄弟连区块链入门教程以太坊源码分析p2p-rlpx节点之间的加密链路二 \/\/ Sign known message: static-shared-secret ^ nonce \/\/ 这个地方应该是直接使用了静态的共享秘密。 使用自己的私钥和对方的公钥生成的一个共享秘密。 token, err = h.staticSharedSecret(prv) if err != nil { return nil, err } \/\/这里我理解用共享秘密来加密这个initNonce。 signed := xor(token, h.initNonce) \/\/ 使用随机的私钥来加密这个信息。 signature, err := crypto.Sign(signed, h.randomPrivKey.ExportECDSA()) if err != nil { return nil, err } msg := new(authMsgV4) copy(msg.Signature[:], signature) \/\/这里把发起者的公钥告知对方。 这样对方使用自己的私钥和这个公钥可以生成静态的共享秘密。 copy(msg.InitiatorPubkey[:], crypto.FromECDSAPub(\x26prv.PublicKey)[1:]) copy(msg.Nonce[:], h.initNonce) msg.Version = 4 return msg, nil } \/\/ staticSharedSecret returns the static shared secret, the result \/\/ of key agreement between the local and remote static node key. func (h *encHandshake) staticSharedSecret(prv *ecdsa.PrivateKey) ([]byte, error) { return ecies.ImportECDSA(prv).GenerateShared(h.remotePub, sskLen, sskLen) } sealEIP8方法，这个方法是一个组包方法，对msg进行rlp的编码。 填充一些数据。 然后使用对方的公钥把数据进行加密。 这意味着只有对方的私钥才能解密这段信息。 func sealEIP8(msg interface{}, h *encHandshake) ([]byte, error) { buf := new(bytes.Buffer) if err := rlp.Encode(buf, msg); err != nil { return nil, err } \/\/ pad with random amount of data. the amount needs to be at least 100 bytes to make \/\/ the message distinguishable from pre-EIP-8 handshakes. pad := padSpace[:mrand.Intn(len(padSpace)-100)\x2b100] buf.Write(pad) prefix := make([]byte, 2) binary.BigEndian.PutUint16(prefix, uint16(buf.Len()\x2beciesOverhead)) enc, err := ecies.Encrypt(rand.Reader, h.remotePub, buf.Bytes(), nil, prefix) return append(prefix, enc...), err } readHandshakeMsg这个方法会从两个地方调用。 一个是在initiatorEncHandshake。一个就是在receiverEncHandshake。 这个方法比较简单。 首先用一种格式尝试解码。如果不行就换另外一种。应该是一种兼容性的设置。 基本上就是使用自己的私钥进行解码然后调用rlp解码成结构体。 结构体的描述就是下面的authRespV4,里面最重要的就是对端的随机公钥。 双方通过自己的私钥和对端的随机公钥可以得到一样的共享秘密。 而这个共享秘密是第三方拿不到的。 \/\/ RLPx v4 handshake response (defined in EIP-8). type authRespV4 struct { RandomPubkey [pubLen]byte Nonce [shaLen]byte Version uint \/\/ Ignore additional fields (forward-compatibility) Rest []rlp.RawValue `rlp:\x22tail\x22` } func readHandshakeMsg(msg plainDecoder, plainSize int, prv *ecdsa.PrivateKey, r io.Reader) ([]byte, error) { buf := make([]byte, plainSize) if _, err := io.ReadFull(r, buf); err != nil { return buf, err } \/\/ Attempt decoding pre-EIP-8 \x22plain\x22 format. key := ecies.ImportECDSA(prv) if dec, err := key.Decrypt(rand.Reader, buf, nil, nil); err == nil { msg.decodePlain(dec) return buf, nil } \/\/ Could be EIP-8 format, try that. prefix := buf[:2] size := binary.BigEndian.Uint16(prefix) if size \x3c uint16(plainSize) { return buf, fmt.Errorf(\x22size underflow, need at least %d bytes\x22, plainSize) } buf = append(buf, make([]byte, size-uint16(plainSize)\x2b2)...) if _, err := io.ReadFull(r, buf[plainSize:]); err != nil { return buf, err } dec, err := key.Decrypt(rand.Reader, buf[2:], nil, prefix) if err != nil { return buf, err } \/\/ Can\x27t use rlp.DecodeBytes here because it rejects \/\/ trailing data (forward-compatibility). s := rlp.NewStream(bytes.NewReader(dec), 0) return buf, s.Decode(msg) } handleAuthResp这个方法非常简单。 func (h *encHandshake) handleAuthResp(msg *authRespV4) (err error) { h.respNonce = msg.Nonce[:] h.remoteRandomPub, err = importPublicKey(msg.RandomPubkey[:]) return err } 最后是secrets函数，这个函数是在handshake完成之后调用。它通过自己的随机私钥和对端的公钥来生成一个共享秘密,这个共享秘密是瞬时的(只在当前这个链接中存在)。所以当有一天私钥被破解。 之前的消息还是安全的。 \/\/ secrets is called after the handshake is completed. \/\/ It extracts the connection secrets from the handshake values. func (h *encHandshake) secrets(auth, authResp []byte) (secrets, error) { ecdheSecret, err := h.randomPrivKey.GenerateShared(h.remoteRandomPub, sskLen, sskLen) if err != nil { return secrets{}, err } \/\/ derive base secrets from ephemeral key agreement sharedSecret := crypto.Keccak256(ecdheSecret, crypto.Keccak256(h.respNonce, h.initNonce)) aesSecret := crypto.Keccak256(ecdheSecret, sharedSecret) \/\/ 实际上这个MAC保护了ecdheSecret这个共享秘密。respNonce和initNonce这三个值 s := secrets{ RemoteID: h.remoteID, AES: aesSecret, MAC: crypto.Keccak256(ecdheSecret, aesSecret), } \/\/ setup sha3 instances for the MACs mac1 := sha3.NewKeccak256() mac1.Write(xor(s.MAC, h.respNonce)) mac1.Write(auth) mac2 := sha3.NewKeccak256() mac2.Write(xor(s.MAC, h.initNonce)) mac2.Write(authResp) \/\/收到的每个包都会检查其MAC值是否满足计算的结果。如果不满足说明有问题。 if h.initiator { s.EgressMAC, s.IngressMAC = mac1, mac2 } else { s.EgressMAC, s.IngressMAC = mac2, mac1 } return s, nil } receiverEncHandshake函数和initiatorEncHandshake的内容大致相同。 但是顺序有些不一样。 \/\/ receiverEncHandshake negotiates a session token on conn. \/\/ it should be called on the listening side of the connection. \/\/ \/\/ prv is the local client\x27s private key. \/\/ token is the token from a previous session with this node. func receiverEncHandshake(conn io.ReadWriter, prv *ecdsa.PrivateKey, token []byte) (s secrets, err error) { authMsg := new(authMsgV4) authPacket, err := readHandshakeMsg(authMsg, encAuthMsgLen, prv, conn) if err != nil { return s, err } h := new(encHandshake) if err := h.handleAuthMsg(authMsg, prv); err != nil { return s, err } authRespMsg, err := h.makeAuthResp() if err != nil { return s, err } var authRespPacket []byte if authMsg.gotPlain { authRespPacket, err = authRespMsg.sealPlain(h) } else { authRespPacket, err = sealEIP8(authRespMsg, h) } if err != nil { return s, err } if _, err = conn.Write(authRespPacket); err != nil { return s, err } return h.secrets(authPacket, authRespPacket) } doProtocolHandshake这个方法比较简单， 加密信道已经创建完毕。 我们看到这里只是约定了是否使用Snappy加密然后就退出了。 \/\/ doEncHandshake runs the protocol handshake using authenticated \/\/ messages. the protocol handshake is the first authenticated message \/\/ and also verifies whether the encryption handshake \x27worked\x27 and the \/\/ remote side actually provided the right public key. func (t *rlpx) doProtoHandshake(our *protoHandshake) (their *protoHandshake, err error) { \/\/ Writing our handshake happens concurrently, we prefer \/\/ returning the handshake read error. If the remote side \/\/ disconnects us early with a valid reason, we should return it \/\/ as the error so it can be tracked elsewhere. werr := make(chan error, 1) go func() { werr \x3c- Send(t.rw, handshakeMsg, our) }() if their, err = readProtocolHandshake(t.rw, our); err != nil { \x3c-werr \/\/ make sure the write terminates too return nil, err } if err := \x3c-werr; err != nil { return nil, fmt.Errorf(\x22write error: %v\x22, err) } \/\/ If the protocol version supports Snappy encoding, upgrade immediately t.rw.snappy = their.Version \x3e= snappyProtocolVersion return their, nil } rlpxFrameRW 数据分帧数据分帧主要通过rlpxFrameRW类来完成的。 \/\/ rlpxFrameRW implements a simplified version of RLPx framing. \/\/ chunked messages are not supported and all headers are equal to \/\/ zeroHeader. \/\/ \/\/ rlpxFrameRW is not safe for concurrent use from multiple goroutines. type rlpxFrameRW struct { conn io.ReadWriter enc cipher.Stream dec cipher.Stream macCipher cipher.Block egressMAC hash.Hash ingressMAC hash.Hash snappy bool } 我们在完成两次握手之后。调用newRLPXFrameRW方法创建了这个对象。 t.rw = newRLPXFrameRW(t.fd, sec) 然后提供ReadMsg和WriteMsg方法。这两个方法直接调用了rlpxFrameRW的ReadMsg和WriteMsg func (t *rlpx) ReadMsg() (Msg, error) { t.rmu.Lock() defer t.rmu.Unlock() t.fd.SetReadDeadline(time.Now().Add(frameReadTimeout)) return t.rw.ReadMsg() } func (t *rlpx) WriteMsg(msg Msg) error { t.wmu.Lock() defer t.wmu.Unlock() t.fd.SetWriteDeadline(time.Now().Add(frameWriteTimeout)) return t.rw.WriteMsg(msg) } WriteMsg func (rw *rlpxFrameRW) WriteMsg(msg Msg) error { ptype, _ := rlp.EncodeToBytes(msg.Code) \/\/ if snappy is enabled, compress message now if rw.snappy { if msg.Size \x3e maxUint24 { return errPlainMessageTooLarge } payload, _ := ioutil.ReadAll(msg.Payload) payload = snappy.Encode(nil, payload) msg.Payload = bytes.NewReader(payload) msg.Size = uint32(len(payload)) } \/\/ write header headbuf := make([]byte, 32) fsize := uint32(len(ptype)) \x2b msg.Size if fsize \x3e maxUint24 { return errors.New(\x22message size overflows uint24\x22) } putInt24(fsize, headbuf) \/\/ TODO: check overflow copy(headbuf[3:], zeroHeader) rw.enc.XORKeyStream(headbuf[:16], headbuf[:16]) \/\/ first half is now encrypted \/\/ write header MAC copy(headbuf[16:], updateMAC(rw.egressMAC, rw.macCipher, headbuf[:16])) if _, err := rw.conn.Write(headbuf); err != nil { return err } \/\/ write encrypted frame, updating the egress MAC hash with \/\/ the data written to conn. tee := cipher.StreamWriter{S: rw.enc, W: io.MultiWriter(rw.conn, rw.egressMAC)} if _, err := tee.Write(ptype); err != nil { return err } if _, err := io.Copy(tee, msg.Payload); err != nil { return err } if padding := fsize % 16; padding \x3e 0 { if _, err := tee.Write(zero16[:16-padding]); err != nil { return err } } \/\/ write frame MAC. egress MAC hash is up to date because \/\/ frame content was written to it as well. fmacseed := rw.egressMAC.Sum(nil) mac := updateMAC(rw.egressMAC, rw.macCipher, fmacseed) _, err := rw.conn.Write(mac) return err } ReadMsg func (rw *rlpxFrameRW) ReadMsg() (msg Msg, err error) { \/\/ read the header headbuf := make([]byte, 32) if _, err := io.ReadFull(rw.conn, headbuf); err != nil { return msg, err } \/\/ verify header mac shouldMAC := updateMAC(rw.ingressMAC, rw.macCipher, headbuf[:16]) if !hmac.Equal(shouldMAC, headbuf[16:]) { return msg, errors.New(\x22bad header MAC\x22) } rw.dec.XORKeyStream(headbuf[:16], headbuf[:16]) \/\/ first half is now decrypted fsize := readInt24(headbuf) \/\/ ignore protocol type for now \/\/ read the frame content var rsize = fsize \/\/ frame size rounded up to 16 byte boundary if padding := fsize % 16; padding \x3e 0 { rsize \x2b= 16 - padding } framebuf := make([]byte, rsize) if _, err := io.ReadFull(rw.conn, framebuf); err != nil { return msg, err } \/\/ read and validate frame MAC. we can re-use headbuf for that. rw.ingressMAC.Write(framebuf) fmacseed := rw.ingressMAC.Sum(nil) if _, err := io.ReadFull(rw.conn, headbuf[:16]); err != nil { return msg, err } shouldMAC = updateMAC(rw.ingressMAC, rw.macCipher, fmacseed) if !hmac.Equal(shouldMAC, headbuf[:16]) { return msg, errors.New(\x22bad frame MAC\x22) } \/\/ decrypt frame content rw.dec.XORKeyStream(framebuf, framebuf) \/\/ decode message code content := bytes.NewReader(framebuf[:fsize]) if err := rlp.Decode(content, \x26msg.Code); err != nil { return msg, err } msg.Size = uint32(content.Len()) msg.Payload = content \/\/ if snappy is enabled, verify and decompress message if rw.snappy { payload, err := ioutil.ReadAll(msg.Payload) if err != nil { return msg, err } size, err := snappy.DecodedLen(payload) if err != nil { return msg, err } if size \x3e int(maxUint24) { return msg, errPlainMessageTooLarge } payload, err = snappy.Decode(nil, payload) if err != nil { return msg, err } msg.Size, msg.Payload = uint32(size), bytes.NewReader(payload) } return msg, nil } 帧结构 normal = not chunked chunked-0 = First frame of a multi-frame packet chunked-n = Subsequent frames for multi-frame packet || is concatenate ^ is xor Single-frame packet: header || header-mac || frame || frame-mac Multi-frame packet: header || header-mac || frame-0 || [ header || header-mac || frame-n || ... || ] header || header-mac || frame-last || frame-mac header: frame-size || header-data || padding frame-size: 3-byte integer size of frame, big endian encoded (excludes padding) header-data: normal: rlp.list(protocol-type[, context-id]) chunked-0: rlp.list(protocol-type, context-id, total-packet-size) chunked-n: rlp.list(protocol-type, context-id) values: protocol-type: \x3c 2**16 context-id: \x3c 2**16 (optional for normal frames) total-packet-size: \x3c 2**32 padding: zero-fill to 16-byte boundary header-mac: right128 of egress-mac.update(aes(mac-secret,egress-mac) ^ header-ciphertext).digest frame: normal: rlp(packet-type) [|| rlp(packet-data)] || padding chunked-0: rlp(packet-type) || rlp(packet-data...) chunked-n: rlp(...packet-data) || padding padding: zero-fill to 16-byte boundary (only necessary for last frame) frame-mac: right128 of egress-mac.update(aes(mac-secret,egress-mac) ^ right128(egress-mac.update(frame-ciphertext).digest)) egress-mac: h256, continuously updated with egress-bytes* ingress-mac: h256, continuously updated with ingress-bytes* 因为加密解密算法我也不是很熟，所以这里的分析还不是很彻底。 暂时只是分析了大致的流程。还有很多细节没有确认。'.length;
	var readTime = Math.round(len / 900);
	if (readTime >= 1) {
		$('.read-time').text('预计阅读时间 '+readTime+' 分钟');
	} else {
		$('.read-time').text('预计阅读时间不到 1 分钟');
	}
});
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/ckeditor/4.6.2/ckeditor.js"></script>
<script type="text/javascript" src="https://static.studygolang.com/static/ckeditor/config.js"></script>
<script type="text/javascript" src="https://static.studygolang.com/static/ckeditor/article.js"></script>


<script type="text/javascript">
$(function(){
	$('code[class*="language-"]').parent('pre').addClass('line-numbers');
});
</script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/prism.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/components/prism-go.min.js"></script>
<script src="https://cdn.staticfile.org/prism/1.9.0/components/prism-json.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/components/prism-bash.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/components/prism-python.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/components/prism-nasm.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/components/prism-yaml.min.js"></script>
<script src="https://cdn.staticfile.org/prism/9000.0.1/plugins/line-numbers/prism-line-numbers.min.js"></script>

<script type="text/javascript">
Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.text = Prism.languages.go;
Prism.languages.golang = Prism.languages.go;
Prism.languages.none = Prism.languages.go;
Prism.languages.console = Prism.languages.bash;
Prism.languages.shell = Prism.languages.bash;
Prism.languages.asm = Prism.languages.nasm;
Prism.languages.makefile = Prism.languages.bash;
Prism.languages.Dockerfile = Prism.languages.bash;
Prism.languages.protobuf = Prism.languages.clike;
Prism.languages.c = Prism.languages.clike;
</script>



	



	




	<script type="text/javascript" src="https://static.studygolang.com/static/dist/js/sidebar.min.js?v=0.2"></script>

	
		
		

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-4512014793067058",
    enable_page_level_ads: true
  });
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-18275235-2', 'auto');
  ga('send', 'pageview');

</script>


<script>
var _hmt = _hmt || [];
if (uid > 0) {
	_hmt.push(['_setUserTag', ''+uid, 1]);
}

(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?224c227cd9239761ec770bc8c1fb134c";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
<script>
(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  } else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();
</script>

	

</body>
</html>
